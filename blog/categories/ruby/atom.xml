<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | 1024Bit  电子游牧日志]]></title>
  <link href="http://woody1983.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://woody1983.github.com/"/>
  <updated>2013-09-08T23:30:44+08:00</updated>
  <id>http://woody1983.github.com/</id>
  <author>
    <name><![CDATA[Johnny Hsu]]></name>
    <email><![CDATA[unix1983@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby inject]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/08/ruby-inject/"/>
    <updated>2013-09-08T23:26:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/08/ruby-inject</id>
    <content type="html"><![CDATA[<p>很早之前再Ruby China问的一个问题 就是1到10 可以创建多少个3位数不重复的组合</p>

<p>现在有了答案!</p>

<p><code>ruby
(1..10).to_a.combination(3).to_a
</code></p>

<p>说实话 这个函数我也没见过 但效果还不错 目测了一把基本是我要的，和数据打交道时间久了就总觉得号码是有规律可言的。上周研习了一下<code>inject</code>的用法 感觉可以做一点小东西出来玩一下。</p>

<p>大乐透的前五位数有多少种组合呢？ 呵呵</p>

<p><code>ruby
(1..35).to_a.combination(5).to_a
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby-Bits]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/05/ruby-bits/"/>
    <updated>2013-09-05T22:10:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/05/ruby-bits</id>
    <content type="html"><![CDATA[<p>关于Ruby最佳实践的记录，我几乎已经放弃向周围的人推荐Ruby这门让人开心的语言了，原因其实很奇怪。</p>

<p>关于参数，Ruby的Function中定义的函数或类总是会接收很多参数 不接受参数的Function不觉得很奇葩吗？</p>

<p>传统的语法和实践是</p>

<p><code>ruby
def CHR(username,login_id,message)
 #...
end
</code></p>

<p>这个不能说错 但按照CodeSchool老师的原话来说<code>Location isn't always used, so let's add default.</code></p>

<p><code>ruby
def CHR(username,login_id=nil,message=nil)
 #...
end
</code></p>

<p>还有一种情况就是参数过多，以致于让function变得毫无可读性<code>have to keep placeholders for arguments you’re not using</code>
这个时候可以采用 <code>HASH Arguments</code></p>

<p>``` ruby</p>

<p>def tweet(message, options = {})
  status = Status.new
  status.lat = options[:lat]
  status.long = options[:long]
  status.body = message
  status.reply_id = options[:reply_id]
  status.post
end
```</p>

<p>调用的时候 就可以利用Symbol来实现多参数。</p>

<p><code>ruby
￼tweet("Practicing Ruby-Fu!",
  :lat =&gt; 28.55,
  :long =&gt; -81.33,
  :reply_id =&gt; 227946
￼￼)
</code></p>

<!-- more -->


<h3>Using Ruby 1.9 hash syntax</h3>

<p>``` ruby
tweet("Practicing Ruby-Fu!",</p>

<pre><code>lat: 28.55,
long: -81.33, 
reply_id: 227946
</code></pre>

<p>)
```</p>

<p>参数的顺序也无所谓了</p>

<p><code>ruby
￼tweet("Practicing Ruby-Fu!",
  reply_id: 227946,
  lat: 28.55,
  long: -81.33
)
</code></p>

<p>一个参数也ok</p>

<p><code>ruby
tweet("Practicing Ruby-Fu!")
</code></p>

<p>``` ruby
def new_game(name, options={})
  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
game = new_game("Street Figher II", year: 1992, system: "SNES")
```</p>

<h3>EXCEPTIONS</h3>

<p>关于判断例外EXCEPTIONS的问题 最传统的写法就是先做判断 有值就出来 如果没值的话 就抛除个神器的东西。貌似这么写程序不太好。</p>

<p>``` ruby
def get_tweets(list)
  if list.authorized?(@user)</p>

<pre><code>list.tweets #如果这个user是验证成功的就把他的tweet列出来
</code></pre>

<p>else</p>

<pre><code>end[] #“magic” return value
</code></pre>

<p>end
```</p>

<p>如果没有tweet 查出来是空的话  还要报一个Error 貌似在Ruby里没这个必要。</p>

<p><code>ruby
tweets = get_tweets(my_list)
if tweets.empty?
  alert "No tweets were found!" +
  "Are you authorized to access this list?"
end
</code></p>

<p>最佳方法应该是用unless先对<code>@user</code>这个对象进行判断 如果没有就用<code>raise</code>来抛除一个异常并返回登陆.</p>

<p>``` ruby
￼def get_tweets(list)
  unless list.authorized?(@user)</p>

<pre><code>raise AuthorizationException.new
</code></pre>

<p>  end
list.tweets
end</p>

<p>begin
  tweets = get_tweets(my_list)
rescue AuthorizationException
  warn "You are not authorized to access this list."
end
```</p>

<p>练习</p>

<p>``` ruby
class InvalidGameError &lt; StandardError; end
def new_game(name, options={})
  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
begin
  game = new_game(nil)
rescue InvalidGameError => e
  puts "There was a problem creating your new game: #{e.message}"
end
```
We want to make sure that each game is a valid game object - in this case a simple hash of values. Even still, we wouldn't want to return a hash with a nil name. Raise an InvalidGameError error in the new_game method if name is nil.</p>

<p>``` ruby
class InvalidGameError &lt; StandardError; end
def new_game(name, options={})</p>

<pre><code>raise InvalidGameError, "You must provide a name for this game." unless name
</code></pre>

<p>  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
begin
  game = new_game(nil)
rescue InvalidGameError => e
  puts "There was a problem creating your new game: #{e.message}"
end
```</p>

<h3>splat arguments</h3>

<p>说实话 我没觉得这个比hash那个要实用</p>

<p>``` ruby
￼def mention(status, *names)
  tweet("#{names.join(' ')} #{status}")
end</p>

<p>mention('Your courses rocked!', 'eallam', 'greggpollack', 'jasonvanlue')</p>

<p>def describe_favorites(*games)
  for game in games</p>

<pre><code>puts "Favorite Game: #{game}"
</code></pre>

<p>  end<br/>
end
describe_favorites('Mario', 'Contra', 'Metroid')
```</p>

<p>为一个二维Array创建一个Class</p>

<p>``` ruby
￼user_names = [
  ["Ashton", "Kutcher"],
  ["Wil", "Wheaton"],
  ["Madonna"]
]</p>

<p>user_names.each { |n| puts "#{n[1]}, #{n[0]}" }
```</p>

<p>这个要直接打印出来 最后那个就会多一个分隔符。</p>

<p>``` ruby
class Name
  def initialize(first, last = nil)</p>

<pre><code>@first = first
@last = last
</code></pre>

<p>  end</p>

<p>￼￼def format</p>

<pre><code>[@last, @first].compact.join(', ')
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[heroku]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/05/heroku/"/>
    <updated>2013-09-05T21:20:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/05/heroku</id>
    <content type="html"><![CDATA[<p>一开始是在 <a href="https://class.coursera.org/startup-001/class/index">Coursera</a>上的公开课学到的 留个记录 以后会天天用到的。</p>

<h3>安装命令很简单 Gem包</h3>

<p><code>gem install heroku</code></p>

<p><code>$ heroku keys</code> 可以查看目前主机中存有的key 如果没有你当前主机的话 就用<code>heroku keys:add</code></p>

<p>Heroku只是一个托管平台而已 Code还是要保存在Github上 需要部署的时候部署过去。我还真不知道怎么从Heroku直接拖Code下来。</p>

<p><code>
$ heroku create semisconblog
Creating semisconblog... done, stack is cedar
http://semisconblog.herokuapp.com/ | git@heroku.com:semisconblog.git
Git remote heroku added
</code>
回头再写 Heroku还是有点不熟悉</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Moudle &amp; Class &amp; Method]]></title>
    <link href="http://woody1983.github.com/blog/2012/12/11/ruby-moudle-and-class-and-method/"/>
    <updated>2012-12-11T15:17:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2012/12/11/ruby-moudle-and-class-and-method</id>
    <content type="html"><![CDATA[<h4>不能创建实例和继承 作用之一是提供namespace 通过使用<code>Moudle.method</code>的方式调用 可以避免方法 常数和类名称的冲突。</h4>

<p>include一个module以后 可以直接调用里面的常数和方法 一般调用方法为</p>

<!-- more -->


<p>``` ruby
module HelloWorld
  Version = "1.0"</p>

<p>  def hello(name)</p>

<pre><code>print "Hi #{name}. \n"
</code></pre>

<p>  end
  #如果该method需要对外部公开的话
  module_function :hello
end
```</p>

<p>调用的时候就是 <code>HelloWorld::Verison</code> or <code>HelloWorld.hello('1024bit')</code></p>

<blockquote><p>Mix-in 讲moduld混到Class中 可以将两个Class中相同的功能植入Module中</p></blockquote>

<p>``` ruby
module MyModule
  #
end</p>

<p>class MyClass1
  include MyModule
end</p>

<p>class MyClass2
  include MyModule
end
```</p>

<h2>Class</h2>

<ul>
<li>初始化方法 initialize</li>
<li>访问方法 <code>attr_reader :name</code> &amp; <code>attr_writer</code> &amp; <code>attr_accessor</code></li>
<li>类变量<code>@@</code>是所有实例共享的变量</li>
<li>类方法 不能对实例操作。或者说实例无法调用类方法</li>
</ul>


<p>类方法的声明三种写法</p>

<p>``` ruby
class HelloWorld
  def HelloWorld.hello(name)</p>

<pre><code>#
</code></pre>

<p>  end
end</p>

<h1>=></h1>

<p>class HelloWorld
  #
end</p>

<p>class &lt;&lt; HelloWorld
  def hello
  end
end</p>

<h1>=></h1>

<p>class HelloWorld
  def self.hello
  end
end
```</p>

<h2>Method</h2>

<p>如果Method的参数过多 建议放到Hash里去处理</p>

<p><code>ruby
def hello(name="Ruby",option={})
  long = options[:long]
  body = message
end
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 错误处理和例外]]></title>
    <link href="http://woody1983.github.com/blog/2012/12/05/ruby-cuo-wu-chu-li-he-li-wai/"/>
    <updated>2012-12-05T11:50:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2012/12/05/ruby-cuo-wu-chu-li-he-li-wai</id>
    <content type="html"><![CDATA[<p>``` ruby
ltotal = 0
wtotal = 0
ctotal = 0</p>

<p>ARGV.each {|file|
  begin</p>

<pre><code>input = File.open(file)
l = 0
w = 0
c = 0
while line = input.gets
  l += 1
  c += line.size
  line.sub!(/^\s+/, "")
  ary = line.split(/\s+/).size
  w += ary.size
end
input.close
printf("%8d %8d %8d %s\n",l,w,c,file)
ltotal += 1
wtotal += 1
ctotal += 1
</code></pre>

<p>  rescue => ex</p>

<pre><code>print "&gt;&gt;&gt;",ex.message,"&lt;&lt;&lt;", "\n"
</code></pre>

<p>  end
}</p>

<p>printf("%8d %8d %8d %s\n",ltotal,wtotal,ctotal,"total")
```</p>

<h3>当无法打开文件阅读的时候，就会将例外报给ex变量 并打印输出。</h3>
]]></content>
  </entry>
  
</feed>
