<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | 1024Bit  电子游牧日志]]></title>
  <link href="http://woody1983.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://woody1983.github.com/"/>
  <updated>2013-09-25T23:51:52+08:00</updated>
  <id>http://woody1983.github.com/</id>
  <author>
    <name><![CDATA[Johnny Hsu]]></name>
    <email><![CDATA[unix1983@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Alias around]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/25/ruby-alias-around/"/>
    <updated>2013-09-25T23:51:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/25/ruby-alias-around</id>
    <content type="html"><![CDATA[<h2>关于环绕别名 实际用途还是蛮多的</h2>

<p>``` ruby
class Myclass
  def greet</p>

<pre><code>puts "Hello!"
</code></pre>

<p>  end</p>

<p>  def greet_with_log</p>

<pre><code>puts "&gt;&gt;&gt;"
greet_without_log #在这里调用的时候 其实是调用的是greet这个方法
puts "&lt;&lt;&lt;"
</code></pre>

<p>  end</p>

<p>  alias_method :greet_without_log, :greet
  alias_method :greet, :greet_with_log #再把含有Log输出的重新别名给greet这个方法</p>

<p>end</p>

<p>Myclass.new.greet_with_log
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Refactoring]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/25/ruby-refactoring/"/>
    <updated>2013-09-25T23:48:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/25/ruby-refactoring</id>
    <content type="html"><![CDATA[<p>这堆神似的函数 越看越不爽 明天用method_missing重构</p>

<p>``` ruby
require 'yaml'</p>

<p>class Datasource</p>

<p>  def initialize()</p>

<pre><code>@dw = YAML.load(File.open('info_price.yml')) 
</code></pre>

<p>  end</p>

<p>  def get_cpu_info(computer_id)</p>

<pre><code>@dw[computer_id]["cpu_info"]
</code></pre>

<p>  end</p>

<p>  def get_cpu_price(computer_id)</p>

<pre><code>@dw[computer_id]["cpu_price"]
</code></pre>

<p>  end</p>

<p>  def get_mouse_info(computer_id)</p>

<pre><code>@dw[computer_id]["mouse_info"]
</code></pre>

<p>  end</p>

<p>  def get_mouse_price(computer_id)</p>

<pre><code>@dw[computer_id]["mouse_price"]
</code></pre>

<p>  end</p>

<p>  def get_memory_info(computer_id)</p>

<pre><code>@dw[computer_id]["memory_info"]
</code></pre>

<p>  end</p>

<p>  def get_memory_price(computer_id)</p>

<pre><code>@dw[computer_id]["memory_price"]
</code></pre>

<p>  end
end</p>

<h1>-- Debug --</h1>

<p>=begin
ds = Datasource.new
puts ds.get_cpu_info(10001)
puts ds.get_cpu_price(10002)
=end
```</p>

<!-- more -->


<h3>参考</h3>

<p>``` ruby
class Computer</p>

<p>  instance_methods.each do |m|</p>

<pre><code>undef_method m unless m.to_s =~ /^__|method_missing|respond_to?|object_id/
</code></pre>

<p>  end</p>

<p>  def initialize(data_source)</p>

<pre><code>#@pc_id = computer_id
@data_source = data_source
</code></pre>

<p>  end</p>

<p>  def method_missing(name, *args)</p>

<pre><code>  super if !respond_to?(name)
  #puts "&gt;&gt;&gt; #{name}, args: #{args}, args class: #{args.class} and size: #{args.size}"

  args.inject(0) do |result,pc_id|
    info = @data_source.send "get_#{name}_info", pc_id
    price = @data_source.send "get_#{name}_price", pc_id
    result = "#{name.capitalize}: #{info}, ($#{price})"
    result = "* #{result}" if price &gt; 1700
    puts result
  end
</code></pre>

<p>  end</p>

<p>  def respond_to?(method)</p>

<pre><code>@data_source.respond_to?("get_#{method}_info") || super
</code></pre>

<p>  end</p>

<p>end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[eigenclass with Module]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/25/eigenclass-with-module/"/>
    <updated>2013-09-25T23:23:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/25/eigenclass-with-module</id>
    <content type="html"><![CDATA[<p>我用了一个很笨的方法才把这个搞明白 那就是...</p>

<h1>Module的eigenclass 不会被任何事物继承  绝对封闭！</h1>

<p><code>元编程#129Pages#Quiz</code></p>

<h3>例子弄错了~在线编辑器害死人  凸</h3>

<p>``` ruby
module MyModule
  def my_method; 'hello';end
end</p>

<p>class Myclass
  include MyModule
end</p>

<p>irb(main):004:0> MyModule.my_method</p>

<h1>NoMethodError: undefined method `my_method' for MyModule:Module</h1>

<p>irb(main):010:0> puts Myclass.my_method</p>

<h1>NoMethodError: undefined method `my_method' for Myclass:Class</h1>

<p>irb(main):011:0> obj = Myclass.new</p>

<h1>=> #&lt;Myclass:0x861fa78></h1>

<p>irb(main):012:0> puts obj.my_method</p>

<h1>hello</h1>

<h1>=> nil</h1>

<p>```</p>

<p>在Module中定义一个普通的实例方法 Myclass Include该Module 只有Myclass的实例obj可以调用
也就是说<code>my_method</code>一直作为实例方法在ancestors中流窜</p>

<!-- more -->


<p>``` ruby
module MyModule</p>

<pre><code>def self.my_method; 'hello';end
</code></pre>

<p>end</p>

<p>class Myclass
  include MyModule
end</p>

<p>irb(main):007:0> MyModule.my_method</p>

<h1>=> "hello"</h1>

<p>irb(main):008:0> Myclass.my_method</p>

<h1>NoMethodError: undefined method `my_method' for Myclass:Class</h1>

<p>irb(main):009:0> obj = Myclass.new</p>

<h1>=> #&lt;Myclass:0x8627980></h1>

<p>irb(main):010:0> obj.my_method</p>

<h1>NoMethodError: undefined method `my_method' for #&lt;Myclass:0x8627980></h1>

<p>```</p>

<p>第二次  将Module中的方法改成是了实例方法  结果正常 只有MyModule可以正常调用  但Myclass并没有继承到
难道在Myclass的eigenclass中并没有得到这个继承？</p>

<p>``` ruby
module MyModule
  def my_method; 'hello';end
end</p>

<p>class Myclass
  class &lt;&lt; self</p>

<pre><code>include MyModule
</code></pre>

<p>  end
end</p>

<p>irb(main):009:0> MyModule.my_method</p>

<h1>NoMethodError: undefined method `my_method' for MyModule:Module</h1>

<p>irb(main):010:0> Myclass.my_method</p>

<h1>=> "hello"</h1>

<p>irb(main):011:0> obj = Myclass.new</p>

<h1>=> #&lt;Myclass:0x8627570></h1>

<p>irb(main):012:0> obj.my_method</p>

<h1>NoMethodError: undefined method `my_method' for #&lt;Myclass:0x8627570></h1>

<p>```</p>

<p>第三次和第一次的修改差异在 将MyModule植入到 Myclass的eigenclass中了~ Myclass可以正常调用该类方法</p>

<h3>可是作为 Myclass的实例对象obj却不能调用这个my_method了</h3>

<p>``` ruby
module MyModule</p>

<pre><code>def self.my_method; 'hello';end
</code></pre>

<p>end</p>

<p>class Myclass
  class &lt;&lt; self</p>

<pre><code>include MyModule
</code></pre>

<p>  end
end</p>

<p>irb(main):009:0> MyModule.my_method</p>

<h1>=> "hello"</h1>

<p>irb(main):010:0> Myclass.my_method</p>

<h1>NoMethodError: undefined method `my_method' for Myclass:Class</h1>

<p>irb(main):011:0> obj = Myclass.new</p>

<h1>=> #&lt;Myclass:0x862bfa8></h1>

<p>irb(main):012:0> puts obj.my_method</p>

<h1>NoMethodError: undefined method `my_method' for #&lt;Myclass:0x862bfa8></h1>

<h1>my_method就算变成Module的类方法以后 还是被继承下来了 和普通的Include看起来效果好像是一样的</h1>

<p>```</p>

<p>第四次和第二次 得到的结果是一样的 也就是进没进Myclass的eigenclass都一样~</p>

<p>我把第四部分重写了一下 加入了另一个实例方法在Module中</p>

<p>``` ruby
module MyModule
  def self.my_method; 'hello';end
  def mine_method; 'another method'; end
end</p>

<p>class Myclass
  class &lt;&lt; self</p>

<pre><code>include MyModule
</code></pre>

<p>  end
end</p>

<p>irb(main):012:0* Myclass.mine_method</p>

<h1>=> "another method"</h1>

<p>irb(main):013:0> Myclass.my_method</p>

<h1>NoMethodError: undefined method `my_method' for Myclass:Class</h1>

<p>```</p>

<p>看来<code>class &lt;&lt; self</code>这种方法只能把MyModule中的实例方法植入到Myclass的eigenclass中 类方法不行</p>

<h2>难道下面这么做是让 MyModule仅仅植入到 Myclass的eigenclass中 而在Myclass中是不可见的？</h2>

<p>``` ruby
class Myclass
  class &lt;&lt; self</p>

<pre><code>include MyModule
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Block & Proc]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/25/ruby-block-proc/"/>
    <updated>2013-09-25T23:19:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/25/ruby-block-proc</id>
    <content type="html"><![CDATA[<p>``` ruby
def math(a,b)</p>

<pre><code>yield(a,b)
</code></pre>

<p>end</p>

<h1>math写成这样子 不跟block是会报错的 因为功能单一 也没必要加上 block_given?</h1>

<p>def teach_math(a,b,&amp;opertion)</p>

<pre><code>puts math(a,b,&amp;opertion)
</code></pre>

<p>end</p>

<h1>opertion加上&amp;意思就是 opertion是个Proc对象 但我当Block来用</h1>

<p>teach_math(2,3) {|x,y| x * y }</p>

<h1>调用的时候2和3会当作参数穿给a和b两个变量 后面挂着的Block会传给opertion对象</h1>

<p>```</p>

<!-- more -->


<p>``` ruby</p>

<h1>稍微修改一下就看出对比了</h1>

<h1>因为math定义了一个yield 所以就必须有一个block挂上去一起玩或者把一个Proc当做block来挂着玩</h1>

<h1>懂？</h1>

<h1>这么写的话  opertion_again就必须是一个proc的对象 使用其自身的call方法来回调</h1>

<p>def math(a,b,opertion_again)</p>

<pre><code>opertion_again.call(a,b)
</code></pre>

<p>end</p>

<p>def teach_math(a, b, &amp;opertion)</p>

<pre><code>puts math(a,b,opertion)#在这里就传进去一个proc对象而不是一个当做block的proc
</code></pre>

<p>end</p>

<p>teach_math(2,3) { |x,y| x * y }</p>

<h1>-------------------Block--->Proc--------------------------------------</h1>

<p>def my_method(&amp;the_proc)</p>

<pre><code>the_proc #去掉了&amp;就变成了一个普通的proc对象并返回出去！
</code></pre>

<p>end</p>

<p>cmp = my_method {|name| "Hello,#{name}!"}#cmp其实是me_method的返回值就是一个proc对象</p>

<h1>所以要call回调</h1>

<p>cmp.call("Johnny")</p>

<h1>-------------------Proc--->Block--------------------------------------</h1>

<p>def my_method(greeting)</p>

<pre><code>puts "#{greeting},#{yield}"#看到yield了就意味着这个方法调用的时候需要跟一个block
</code></pre>

<p>end</p>

<p>my_proc = proc { "Woody" } #声明一个proc对象</p>

<p>my_method("Hello",&amp;my_proc)#把Proc当Block ！again!</p>

<p>```</p>

<p>``` ruby
def me_method()
  yield
end</p>

<h1>puts my_method { "xXx" }   => "xXx"</h1>

<p>def me_method2(&amp;my_proc)
  my_proc.call
end</p>

<h1>me_method2 { "xXx" }   => "xXx"</h1>

<h1>当你会把Block和Proc串起来玩的时候  可调用对象的概念应该了解的差不多了</h1>

<p>def me_method()
  yield
end</p>

<p>def me_method2(&amp;my_proc)
  me_method(&amp;my_proc)
end</p>

<p>me_method2 { "<em>why" } # => "</em>why"
```</p>

<blockquote><p>这两个方法在调用的时候都需要跟一个block</p></blockquote>

<h3>大招</h3>

<p>``` ruby
["1", "2", "3"].map(&amp;:to_i)</p>

<h1>其效果和下面这个一样</h1>

<p>["1", "2", "3"].map {|i| i.to_i }
```</p>

<blockquote><p>Reg Braithwaite简单地介绍了to_proc是怎样让 (1..100).inject(&amp;:+) 这样的代码工作的:</p></blockquote>

<p>&amp; 操作符用来把Proc对象转化成块，或者把块转化成Proc对象。这此例中，它试图把符号 :+ 转换成一个块。此转换过程使用了Ruby内建的强制机制。这个机制会检查我们是否有一个Proc对象。如果没有，它就把#to_proc方法传递到参数中 来生成一个Proc。如果符号 :+ 有#to_proc方法，就调用它。在Ruby 1.9中，它就有一个#to_proc方法。此方法使用了第一个参数，然后返回一个Proc，并把 + 方法和其他参数传递给它。
由此可见，&amp;:+ 实际上就是 { |x, y| x + y }</p>

<p>``` ruby
(1..5).map(&amp;:to_s)</p>

<h1>=> ["1", "2", "3", "4", "5"]</h1>

<p>(1..5).map{|x| x.to_s }</p>

<h1>=> ["1", "2", "3", "4", "5"]</h1>

<p> ["woody","johnny"].map(&amp;:capitalize)</p>

<h1>=> ["Woody", "Johnny"]</h1>

<p>```</p>

<h3>另一种可调用对象的方法  .method</h3>

<p>``` ruby
class MyClass</p>

<pre><code>def initialize(value)
    @name = value
end

def my_method
    @name.capitalize
end
</code></pre>

<p>end</p>

<p>object = MyClass.new("woody")
cmp = object.method :my_method
cmp.class #=> Method
cmp.call #=> "Woody"</p>

<h1>String.instance_methods</h1>

<p>```</p>

<h3>instance_eval</h3>

<p><code>object#instance_eval</code> 可以在对象的上下文中执行一个Block</p>

<p>``` ruby
@setups = []</p>

<h1>初始化</h1>

<p>def setup(&amp;block)
  @setups &lt;&lt; block
end</p>

<p>setup do
  puts "[\033[1;36;40m Setting up \033[m] [\033[1;37;40m Sky \033[m]"
  @sky_height = 100
end</p>

<p>setup do
  puts "[\033[1;36;40m Setting up \033[m] [\033[1;37;40m Mountains \033[m]"
  @mountains_height = 200
end</p>

<p> @setups.each {|setup| env.instance_eval &amp;setup }
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby On Kettle]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/09/ruby-on-kettle/"/>
    <updated>2013-09-09T22:34:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/09/ruby-on-kettle</id>
    <content type="html"><![CDATA[<p><code>ruby
1.9.3-p194 :009 &gt; "1111111111".to_i(2)
 =&gt; 1023
1.9.3-p194 :010 &gt; 1023.to_s(2)
 =&gt; "1111111111"
</code></p>

<p>总要为Kettle做点什么 用二进制来完成一对多线路分发 监控就成了主要的问题。</p>

<p><code>ruby
1.9.3-p194 :013 &gt; "1111111111".size
 =&gt; 10
1.9.3-p194 :014 &gt; "1111111111".length
 =&gt; 10
</code></p>

<h4>10位对应10个分发线路</h4>

<p>一个最常见的问题 我需要充值某条数据的某个线路重新发送 或者紧急止停某条线路的一批数据下发，so 要定位</p>

<p><code>ruby
1.9.3-p194 :016 &gt; "1111111111".split('')
 =&gt; ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]
</code></p>

<h4>重置Reset 0号线路 也就是Array最右边那个</h4>

<p><code>ruby
1.9.3-p194 :021 &gt; rok = "1111111111".split('')
 =&gt; ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]
1.9.3-p194 :022 &gt; rok
 =&gt; ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]
1.9.3-p194 :023 &gt; rok[10-1]
 =&gt; "1"
1.9.3-p194 :024 &gt; rok[10-1] = "0"
 =&gt; "0"
1.9.3-p194 :025 &gt; rok
 =&gt; ["1", "1", "1", "1", "1", "1", "1", "1", "1", "0"]
</code></p>

<p><code>明天抽时间写一个Class 封装这个动作</code></p>

<h3>我想要的功能应该有</h3>

<ul>
<li>Preview Kettle当前运行状况和<code>质量</code></li>
<li>单独查看某个线路或某张表的下发情况 <code>时间</code> &amp; <code>Error</code> &amp; <code>Count</code></li>
<li>Error 单独分析和Email寄送功能</li>
<li>Reset 下发Status</li>
</ul>

]]></content>
  </entry>
  
</feed>
