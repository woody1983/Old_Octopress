<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | 1024Bit  电子游牧日志]]></title>
  <link href="http://woody1983.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://woody1983.github.com/"/>
  <updated>2013-09-25T23:45:26+08:00</updated>
  <id>http://woody1983.github.com/</id>
  <author>
    <name><![CDATA[Johnny Hsu]]></name>
    <email><![CDATA[unix1983@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[eigenclass with Module]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/25/eigenclass-with-module/"/>
    <updated>2013-09-25T23:23:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/25/eigenclass-with-module</id>
    <content type="html"><![CDATA[<p>我用了一个很笨的方法才把这个搞明白 那就是...</p>

<h1>Module的eigenclass 不会被任何事物继承  绝对封闭！</h1>

<p><code>元编程#129Pages#Quiz</code></p>

<h3>例子弄错了~在线编辑器害死人  凸</h3>

<p>``` ruby
module MyModule
  def my_method; 'hello';end
end</p>

<p>class Myclass
  include MyModule
end</p>

<p>irb(main):004:0> MyModule.my_method</p>

<h1>NoMethodError: undefined method `my_method' for MyModule:Module</h1>

<p>irb(main):010:0> puts Myclass.my_method</p>

<h1>NoMethodError: undefined method `my_method' for Myclass:Class</h1>

<p>irb(main):011:0> obj = Myclass.new</p>

<h1>=> #&lt;Myclass:0x861fa78></h1>

<p>irb(main):012:0> puts obj.my_method</p>

<h1>hello</h1>

<h1>=> nil</h1>

<p>```</p>

<p>在Module中定义一个普通的实例方法 Myclass Include该Module 只有Myclass的实例obj可以调用
也就是说<code>my_method</code>一直作为实例方法在ancestors中流窜</p>

<!-- more -->


<p>``` ruby
module MyModule</p>

<pre><code>def self.my_method; 'hello';end
</code></pre>

<p>end</p>

<p>class Myclass
  include MyModule
end</p>

<p>irb(main):007:0> MyModule.my_method</p>

<h1>=> "hello"</h1>

<p>irb(main):008:0> Myclass.my_method</p>

<h1>NoMethodError: undefined method `my_method' for Myclass:Class</h1>

<p>irb(main):009:0> obj = Myclass.new</p>

<h1>=> #&lt;Myclass:0x8627980></h1>

<p>irb(main):010:0> obj.my_method</p>

<h1>NoMethodError: undefined method `my_method' for #&lt;Myclass:0x8627980></h1>

<p>```</p>

<p>第二次  将Module中的方法改成是了实例方法  结果正常 只有MyModule可以正常调用  但Myclass并没有继承到
难道在Myclass的eigenclass中并没有得到这个继承？</p>

<p>``` ruby
module MyModule
  def my_method; 'hello';end
end</p>

<p>class Myclass
  class &lt;&lt; self</p>

<pre><code>include MyModule
</code></pre>

<p>  end
end</p>

<p>irb(main):009:0> MyModule.my_method</p>

<h1>NoMethodError: undefined method `my_method' for MyModule:Module</h1>

<p>irb(main):010:0> Myclass.my_method</p>

<h1>=> "hello"</h1>

<p>irb(main):011:0> obj = Myclass.new</p>

<h1>=> #&lt;Myclass:0x8627570></h1>

<p>irb(main):012:0> obj.my_method</p>

<h1>NoMethodError: undefined method `my_method' for #&lt;Myclass:0x8627570></h1>

<p>```</p>

<p>第三次和第一次的修改差异在 将MyModule植入到 Myclass的eigenclass中了~ Myclass可以正常调用该类方法</p>

<h3>可是作为 Myclass的实例对象obj却不能调用这个my_method了</h3>

<p>``` ruby
module MyModule</p>

<pre><code>def self.my_method; 'hello';end
</code></pre>

<p>end</p>

<p>class Myclass
  class &lt;&lt; self</p>

<pre><code>include MyModule
</code></pre>

<p>  end
end</p>

<p>irb(main):009:0> MyModule.my_method</p>

<h1>=> "hello"</h1>

<p>irb(main):010:0> Myclass.my_method</p>

<h1>NoMethodError: undefined method `my_method' for Myclass:Class</h1>

<p>irb(main):011:0> obj = Myclass.new</p>

<h1>=> #&lt;Myclass:0x862bfa8></h1>

<p>irb(main):012:0> puts obj.my_method</p>

<h1>NoMethodError: undefined method `my_method' for #&lt;Myclass:0x862bfa8></h1>

<h1>my_method就算变成Module的类方法以后 还是被继承下来了 和普通的Include看起来效果好像是一样的</h1>

<p>```</p>

<p>第四次和第二次 得到的结果是一样的 也就是进没进Myclass的eigenclass都一样~</p>

<p>我把第四部分重写了一下 加入了另一个实例方法在Module中</p>

<p>``` ruby
module MyModule
  def self.my_method; 'hello';end
  def mine_method; 'another method'; end
end</p>

<p>class Myclass
  class &lt;&lt; self</p>

<pre><code>include MyModule
</code></pre>

<p>  end
end</p>

<p>irb(main):012:0* Myclass.mine_method</p>

<h1>=> "another method"</h1>

<p>irb(main):013:0> Myclass.my_method</p>

<h1>NoMethodError: undefined method `my_method' for Myclass:Class</h1>

<p>```</p>

<p>看来<code>class &lt;&lt; self</code>这种方法只能把MyModule中的实例方法植入到Myclass的eigenclass中 类方法不行</p>

<h2>难道下面这么做是让 MyModule仅仅植入到 Myclass的eigenclass中 而在Myclass中是不可见的？</h2>

<p>``` ruby
class Myclass
  class &lt;&lt; self</p>

<pre><code>include MyModule
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Block & Proc]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/25/ruby-block-proc/"/>
    <updated>2013-09-25T23:19:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/25/ruby-block-proc</id>
    <content type="html"><![CDATA[<p>``` ruby
def math(a,b)</p>

<pre><code>yield(a,b)
</code></pre>

<p>end</p>

<h1>math写成这样子 不跟block是会报错的 因为功能单一 也没必要加上 block_given?</h1>

<p>def teach_math(a,b,&amp;opertion)</p>

<pre><code>puts math(a,b,&amp;opertion)
</code></pre>

<p>end</p>

<h1>opertion加上&amp;意思就是 opertion是个Proc对象 但我当Block来用</h1>

<p>teach_math(2,3) {|x,y| x * y }</p>

<h1>调用的时候2和3会当作参数穿给a和b两个变量 后面挂着的Block会传给opertion对象</h1>

<p>```</p>

<!-- more -->


<p>``` ruby</p>

<h1>稍微修改一下就看出对比了</h1>

<h1>因为math定义了一个yield 所以就必须有一个block挂上去一起玩或者把一个Proc当做block来挂着玩</h1>

<h1>懂？</h1>

<h1>这么写的话  opertion_again就必须是一个proc的对象 使用其自身的call方法来回调</h1>

<p>def math(a,b,opertion_again)</p>

<pre><code>opertion_again.call(a,b)
</code></pre>

<p>end</p>

<p>def teach_math(a, b, &amp;opertion)</p>

<pre><code>puts math(a,b,opertion)#在这里就传进去一个proc对象而不是一个当做block的proc
</code></pre>

<p>end</p>

<p>teach_math(2,3) { |x,y| x * y }</p>

<h1>-------------------Block--->Proc--------------------------------------</h1>

<p>def my_method(&amp;the_proc)</p>

<pre><code>the_proc #去掉了&amp;就变成了一个普通的proc对象并返回出去！
</code></pre>

<p>end</p>

<p>cmp = my_method {|name| "Hello,#{name}!"}#cmp其实是me_method的返回值就是一个proc对象</p>

<h1>所以要call回调</h1>

<p>cmp.call("Johnny")</p>

<h1>-------------------Proc--->Block--------------------------------------</h1>

<p>def my_method(greeting)</p>

<pre><code>puts "#{greeting},#{yield}"#看到yield了就意味着这个方法调用的时候需要跟一个block
</code></pre>

<p>end</p>

<p>my_proc = proc { "Woody" } #声明一个proc对象</p>

<p>my_method("Hello",&amp;my_proc)#把Proc当Block ！again!</p>

<p>```</p>

<p>``` ruby
def me_method()
  yield
end</p>

<h1>puts my_method { "xXx" }   => "xXx"</h1>

<p>def me_method2(&amp;my_proc)
  my_proc.call
end</p>

<h1>me_method2 { "xXx" }   => "xXx"</h1>

<h1>当你会把Block和Proc串起来玩的时候  可调用对象的概念应该了解的差不多了</h1>

<p>def me_method()
  yield
end</p>

<p>def me_method2(&amp;my_proc)
  me_method(&amp;my_proc)
end</p>

<p>me_method2 { "<em>why" } # => "</em>why"
```</p>

<blockquote><p>这两个方法在调用的时候都需要跟一个block</p></blockquote>

<h3>大招</h3>

<p>``` ruby
["1", "2", "3"].map(&amp;:to_i)</p>

<h1>其效果和下面这个一样</h1>

<p>["1", "2", "3"].map {|i| i.to_i }
```</p>

<blockquote><p>Reg Braithwaite简单地介绍了to_proc是怎样让 (1..100).inject(&amp;:+) 这样的代码工作的:</p></blockquote>

<p>&amp; 操作符用来把Proc对象转化成块，或者把块转化成Proc对象。这此例中，它试图把符号 :+ 转换成一个块。此转换过程使用了Ruby内建的强制机制。这个机制会检查我们是否有一个Proc对象。如果没有，它就把#to_proc方法传递到参数中 来生成一个Proc。如果符号 :+ 有#to_proc方法，就调用它。在Ruby 1.9中，它就有一个#to_proc方法。此方法使用了第一个参数，然后返回一个Proc，并把 + 方法和其他参数传递给它。
由此可见，&amp;:+ 实际上就是 { |x, y| x + y }</p>

<p>``` ruby
(1..5).map(&amp;:to_s)</p>

<h1>=> ["1", "2", "3", "4", "5"]</h1>

<p>(1..5).map{|x| x.to_s }</p>

<h1>=> ["1", "2", "3", "4", "5"]</h1>

<p> ["woody","johnny"].map(&amp;:capitalize)</p>

<h1>=> ["Woody", "Johnny"]</h1>

<p>```</p>

<h3>另一种可调用对象的方法  .method</h3>

<p>``` ruby
class MyClass</p>

<pre><code>def initialize(value)
    @name = value
end

def my_method
    @name.capitalize
end
</code></pre>

<p>end</p>

<p>object = MyClass.new("woody")
cmp = object.method :my_method
cmp.class #=> Method
cmp.call #=> "Woody"</p>

<h1>String.instance_methods</h1>

<p>```</p>

<h3>instance_eval</h3>

<p><code>object#instance_eval</code> 可以在对象的上下文中执行一个Block</p>

<p>``` ruby
@setups = []</p>

<h1>初始化</h1>

<p>def setup(&amp;block)
  @setups &lt;&lt; block
end</p>

<p>setup do
  puts "[\033[1;36;40m Setting up \033[m] [\033[1;37;40m Sky \033[m]"
  @sky_height = 100
end</p>

<p>setup do
  puts "[\033[1;36;40m Setting up \033[m] [\033[1;37;40m Mountains \033[m]"
  @mountains_height = 200
end</p>

<p> @setups.each {|setup| env.instance_eval &amp;setup }
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby On Kettle]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/09/ruby-on-kettle/"/>
    <updated>2013-09-09T22:34:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/09/ruby-on-kettle</id>
    <content type="html"><![CDATA[<p><code>ruby
1.9.3-p194 :009 &gt; "1111111111".to_i(2)
 =&gt; 1023
1.9.3-p194 :010 &gt; 1023.to_s(2)
 =&gt; "1111111111"
</code></p>

<p>总要为Kettle做点什么 用二进制来完成一对多线路分发 监控就成了主要的问题。</p>

<p><code>ruby
1.9.3-p194 :013 &gt; "1111111111".size
 =&gt; 10
1.9.3-p194 :014 &gt; "1111111111".length
 =&gt; 10
</code></p>

<h4>10位对应10个分发线路</h4>

<p>一个最常见的问题 我需要充值某条数据的某个线路重新发送 或者紧急止停某条线路的一批数据下发，so 要定位</p>

<p><code>ruby
1.9.3-p194 :016 &gt; "1111111111".split('')
 =&gt; ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]
</code></p>

<h4>重置Reset 0号线路 也就是Array最右边那个</h4>

<p><code>ruby
1.9.3-p194 :021 &gt; rok = "1111111111".split('')
 =&gt; ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]
1.9.3-p194 :022 &gt; rok
 =&gt; ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]
1.9.3-p194 :023 &gt; rok[10-1]
 =&gt; "1"
1.9.3-p194 :024 &gt; rok[10-1] = "0"
 =&gt; "0"
1.9.3-p194 :025 &gt; rok
 =&gt; ["1", "1", "1", "1", "1", "1", "1", "1", "1", "0"]
</code></p>

<p><code>明天抽时间写一个Class 封装这个动作</code></p>

<h3>我想要的功能应该有</h3>

<ul>
<li>Preview Kettle当前运行状况和<code>质量</code></li>
<li>单独查看某个线路或某张表的下发情况 <code>时间</code> &amp; <code>Error</code> &amp; <code>Count</code></li>
<li>Error 单独分析和Email寄送功能</li>
<li>Reset 下发Status</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby inject]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/08/ruby-inject/"/>
    <updated>2013-09-08T23:26:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/08/ruby-inject</id>
    <content type="html"><![CDATA[<p>很早之前再Ruby China问的一个问题 就是1到10 可以创建多少个3位数不重复的组合</p>

<p>现在有了答案!</p>

<p><code>ruby
(1..10).to_a.combination(3).to_a
</code></p>

<p>说实话 这个函数我也没见过 但效果还不错 目测了一把基本是我要的，和数据打交道时间久了就总觉得号码是有规律可言的。上周研习了一下<code>inject</code>的用法 感觉可以做一点小东西出来玩一下。</p>

<p>大乐透的前五位数有多少种组合呢？ 呵呵</p>

<p><code>ruby
(1..35).to_a.combination(5).to_a
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby-Bits]]></title>
    <link href="http://woody1983.github.com/blog/2013/09/05/ruby-bits/"/>
    <updated>2013-09-05T22:10:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/09/05/ruby-bits</id>
    <content type="html"><![CDATA[<p>关于Ruby最佳实践的记录，我几乎已经放弃向周围的人推荐Ruby这门让人开心的语言了，原因其实很奇怪。</p>

<p>关于参数，Ruby的Function中定义的函数或类总是会接收很多参数 不接受参数的Function不觉得很奇葩吗？</p>

<p>传统的语法和实践是</p>

<p><code>ruby
def CHR(username,login_id,message)
 #...
end
</code></p>

<p>这个不能说错 但按照CodeSchool老师的原话来说<code>Location isn't always used, so let's add default.</code></p>

<p><code>ruby
def CHR(username,login_id=nil,message=nil)
 #...
end
</code></p>

<p>还有一种情况就是参数过多，以致于让function变得毫无可读性<code>have to keep placeholders for arguments you’re not using</code>
这个时候可以采用 <code>HASH Arguments</code></p>

<p>``` ruby</p>

<p>def tweet(message, options = {})
  status = Status.new
  status.lat = options[:lat]
  status.long = options[:long]
  status.body = message
  status.reply_id = options[:reply_id]
  status.post
end
```</p>

<p>调用的时候 就可以利用Symbol来实现多参数。</p>

<p><code>ruby
￼tweet("Practicing Ruby-Fu!",
  :lat =&gt; 28.55,
  :long =&gt; -81.33,
  :reply_id =&gt; 227946
￼￼)
</code></p>

<!-- more -->


<h3>Using Ruby 1.9 hash syntax</h3>

<p>``` ruby
tweet("Practicing Ruby-Fu!",</p>

<pre><code>lat: 28.55,
long: -81.33, 
reply_id: 227946
</code></pre>

<p>)
```</p>

<p>参数的顺序也无所谓了</p>

<p><code>ruby
￼tweet("Practicing Ruby-Fu!",
  reply_id: 227946,
  lat: 28.55,
  long: -81.33
)
</code></p>

<p>一个参数也ok</p>

<p><code>ruby
tweet("Practicing Ruby-Fu!")
</code></p>

<p>``` ruby
def new_game(name, options={})
  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
game = new_game("Street Figher II", year: 1992, system: "SNES")
```</p>

<h3>EXCEPTIONS</h3>

<p>关于判断例外EXCEPTIONS的问题 最传统的写法就是先做判断 有值就出来 如果没值的话 就抛除个神器的东西。貌似这么写程序不太好。</p>

<p>``` ruby
def get_tweets(list)
  if list.authorized?(@user)</p>

<pre><code>list.tweets #如果这个user是验证成功的就把他的tweet列出来
</code></pre>

<p>else</p>

<pre><code>end[] #“magic” return value
</code></pre>

<p>end
```</p>

<p>如果没有tweet 查出来是空的话  还要报一个Error 貌似在Ruby里没这个必要。</p>

<p><code>ruby
tweets = get_tweets(my_list)
if tweets.empty?
  alert "No tweets were found!" +
  "Are you authorized to access this list?"
end
</code></p>

<p>最佳方法应该是用unless先对<code>@user</code>这个对象进行判断 如果没有就用<code>raise</code>来抛除一个异常并返回登陆.</p>

<p>``` ruby
￼def get_tweets(list)
  unless list.authorized?(@user)</p>

<pre><code>raise AuthorizationException.new
</code></pre>

<p>  end
list.tweets
end</p>

<p>begin
  tweets = get_tweets(my_list)
rescue AuthorizationException
  warn "You are not authorized to access this list."
end
```</p>

<p>练习</p>

<p>``` ruby
class InvalidGameError &lt; StandardError; end
def new_game(name, options={})
  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
begin
  game = new_game(nil)
rescue InvalidGameError => e
  puts "There was a problem creating your new game: #{e.message}"
end
```
We want to make sure that each game is a valid game object - in this case a simple hash of values. Even still, we wouldn't want to return a hash with a nil name. Raise an InvalidGameError error in the new_game method if name is nil.</p>

<p>``` ruby
class InvalidGameError &lt; StandardError; end
def new_game(name, options={})</p>

<pre><code>raise InvalidGameError, "You must provide a name for this game." unless name
</code></pre>

<p>  {</p>

<pre><code>name: name,
year: options[:year],
system: options[:system]
</code></pre>

<p>  }
end
begin
  game = new_game(nil)
rescue InvalidGameError => e
  puts "There was a problem creating your new game: #{e.message}"
end
```</p>

<h3>splat arguments</h3>

<p>说实话 我没觉得这个比hash那个要实用</p>

<p>``` ruby
￼def mention(status, *names)
  tweet("#{names.join(' ')} #{status}")
end</p>

<p>mention('Your courses rocked!', 'eallam', 'greggpollack', 'jasonvanlue')</p>

<p>def describe_favorites(*games)
  for game in games</p>

<pre><code>puts "Favorite Game: #{game}"
</code></pre>

<p>  end<br/>
end
describe_favorites('Mario', 'Contra', 'Metroid')
```</p>

<p>为一个二维Array创建一个Class</p>

<p>``` ruby
￼user_names = [
  ["Ashton", "Kutcher"],
  ["Wil", "Wheaton"],
  ["Madonna"]
]</p>

<p>user_names.each { |n| puts "#{n[1]}, #{n[0]}" }
```</p>

<p>这个要直接打印出来 最后那个就会多一个分隔符。</p>

<p>``` ruby
class Name
  def initialize(first, last = nil)</p>

<pre><code>@first = first
@last = last
</code></pre>

<p>  end</p>

<p>￼￼def format</p>

<pre><code>[@last, @first].compact.join(', ')
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
</feed>
