<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | 1024Bit  电子游牧日志]]></title>
  <link href="http://woody1983.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://woody1983.github.com/"/>
  <updated>2012-12-25T16:11:32+08:00</updated>
  <id>http://woody1983.github.com/</id>
  <author>
    <name><![CDATA[Woody.Xu]]></name>
    <email><![CDATA[unix1983@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[mvc]]></title>
    <link href="http://woody1983.github.com/blog/2012/08/22/mvc/"/>
    <updated>2012-08-22T00:36:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2012/08/22/mvc</id>
    <content type="html"><![CDATA[<p><img src="http://ruby.railstutorial.org/images/figures/mvc_detailed.png" alt="About MVC" />
* The browser issues a request for the /users URI.
* Rails routes /users to the index action in the Users controller.
* The index action asks the User model to retrieve all users (User.all).
* The User model pulls all the users from the database.
* The User model returns the list of users to the controller.
* The controller captures the users in the @users variable, which is passed to the index view.
* The view uses embedded Ruby to render the page as HTML.
* The controller passes the HTML back to the browser.3</p>

<p><img src="http://ruby.railstutorial.org/images/figures/demo_controller_inheritance.png" title="Optional title attribute" alt="About Controller" />
<code>app/controllers/application_controller.rb</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails学习全记录]]></title>
    <link href="http://woody1983.github.com/blog/2012/08/22/rails-notes/"/>
    <updated>2012-08-22T00:10:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2012/08/22/rails-notes</id>
    <content type="html"><![CDATA[<h3>创建rails项目 跳过unit-test模块</h3>

<p><code>rails new sample_app --skip-test-unit</code></p>

<h3>不安装production环境所需要的gem</h3>

<p><code>bundle install --without production</code></p>

<h3>创建rspec测试模块</h3>

<p><code>rails generate rspec:install</code></p>

<h3>创建一个负责静态页面的控制器</h3>

<p><code>rails generate controller StaticPages home help --no-test-framework</code></p>

<p>其实还可以添加 about contact等方法</p>

<p>删除一个控制器<code>rails destroy  controller FooBars baz quux</code></p>

<!-- more -->


<h3>route中的get方法</h3>

<p><code>config/routes.rb</code></p>

<p>by using get we arrange for the route to respond to a GET request
<code>get "static_pages/about"</code></p>

<h4>The first step is to generate an integration test (request spec) for our static pages:</h4>

<p>```
$ rails generate integration_test static_pages</p>

<pre><code>  invoke  rspec
  create    spec/requests/static_pages_spec.rb
</code></pre>

<p>```</p>

<h1>About RSpec</h1>

<p>```
describe "场景/描述“ do
  it "..." do</p>

<pre><code>...
</code></pre>

<p>  end
end
```</p>

<h4>一段it语句</h4>

<p>```
it "should have the content 'Sample App'" do #应该可以看到Sample App这个字样</p>

<pre><code>  visit '/static_pages/home' #访问这个path
  page.should have_content('Sample App') #页面上(page) 应该会包含这个content
end
</code></pre>

<p>```</p>

<h1>should and should_not 一招鲜</h1>

<p>uses the <code>Capybara</code> function <code>visit</code></p>

<p><code>spec/requests/static_pages_spec.rb</code> 可以将不同的静态页面定义到不同的describe中去测试 测试指定页面中是否包含什么文字</p>

<h3>再添加一个静态页面呢？</h3>

<ul>
<li>首先route中需要添加新的<code>get "static_pages/about"</code></li>
<li>controllers指定def</li>
<li>views中有对应的<code>html</code>页面<code>app/views/static_pages/about.html.erb</code></li>
</ul>


<h4>选择测试某一个元素 比如 title h1 等</h4>

<p>```
page.should have_selector('title',</p>

<pre><code>                :text =&gt; "Ruby on Rails Tutorial Sample App | Home")
</code></pre>

<p><code>``
This uses the have_selector method, which checks for an HTML element (the “selector”) with the given content.
要查找的内容也可以用缩写 只寻找</code>关键字<code>
</code>page.should have_selector('title', :text => " | Home")`</p>

<h3>Provide方法 可以提供临时变量给一个label</h3>

<p><code>&lt;% provide(:title, 'Home') %&gt;</code></p>

<h5>使用</h5>

<p><code>&lt;title&gt;Ruby on Rails Tutorial Sample App | &lt;%= yield(:title) %&gt;&lt;/title&gt;</code></p>

<blockquote><p>http://ruby.railstutorial.org/chapters/static-pages#top 明天继续</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于rspec浅见]]></title>
    <link href="http://woody1983.github.com/blog/2012/08/20/about-rspec/"/>
    <updated>2012-08-20T20:52:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2012/08/20/about-rspec</id>
    <content type="html"><![CDATA[<h3>刚入手没几天，感觉开发过程中多了很多乐趣。</h3>

<p><code>should</code> and <code>should_not</code></p>

<h2>before and after</h2>

<p>before(:each) 每段it之前执行
before(:all) 每段describe 之前执行
after(:each)
after(:all)</p>

<h3>pending 可以先列出来打算要写的代码</h3>

<p><code>ruby
it "…"
  pending
end
</code></p>

<!-- more-->


<h3>let 语法 有需要才会出来运算。</h3>

<p><code>ruby
let(:user) {User.new(:is_vip =&gt; true)
</code></p>

<h3>should 后面</h3>

<p>be_true
be_false
be_nil</p>

<h3>检查class和def</h3>

<ul>
<li>target.should be_a_kind_of(Array)      <code>target.class.should == Array</code></li>
<li>target.should be_an_instance_of(Array) <code>target.class.should == Array</code></li>
<li>target.should respond_to(:foo)         <code>target.respond_to?(:foo).should == true</code></li>
</ul>


<h3>检查array hash</h3>

<ul>
<li>target.should have_key(:foo) <code>#target[:foo].should_not == nil</code></li>
<li>target.should include(4)     <code>#target.include?(4).should == true</code></li>
<li>target.should have(3).items  <code>#target.items.length == 3</code></li>
</ul>


<h3>任何be_开头的</h3>

<ul>
<li>target.should be_empty <code>#target.empty?.should == true</code></li>
<li>target.should be_blank <code>#target.blank?.should == true</code></li>
<li>target.should be_admin <code>#target.admin?.should == true</code></li>
</ul>


<h3>should ==   一招鲜吃遍天</h3>

<h3>expect to</h3>

<h4>希望一段代码会改变某个值货丢出例外</h4>

<p><code>ruby
it "should update status to shipping" do
  expect{order.ship!}.to change{order.status}.from("new").to("shippping")
end
</code></p>

<h4>希望status从new变成shipping</h4>

<p>和这段差不多</p>

<p><code>ruby
it "should update status to shipping "do
order.status.should == "new"
order.ship!
order.status.should == "shipping"
end
</code></p>

<h3>subject 可以省略 receiver</h3>

<p><code>ruby
subject {Order.new(:status =&gt; "New")}
it {should be_valid} #subject.valid?should == true
its(:status){should == "New"} #subject.status.should == "New"
</code></p>

<h3>it example specify 是一样的 都是别名</h3>

<h4>rspec filename.rb -fs 输出specdox文件</h4>

<h4>rspec filename.rb -fh 输出html文件</h4>

<h3>useful Rspec tools</h3>

<ul>
<li>factory_girl 造测试数据</li>
<li>shoulda 更多rails专用的matcher</li>
<li>capybara 提供浏览器模拟</li>
</ul>


<h3>rcov 测试覆盖度 看有哪些代码没有测试到</h3>

<h3>Capydara</h3>

<ul>
<li>fill_in 'Login', :with=>'username'</li>
<li>click_link 'Sign up'</li>
</ul>


<h3>每个it只有一个测试目的。不被周边因素影响</h3>
]]></content>
  </entry>
  
</feed>
