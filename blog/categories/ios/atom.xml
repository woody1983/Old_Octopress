<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: IOS | 1024Bit  电子游牧日志]]></title>
  <link href="http://woody1983.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://woody1983.github.com/"/>
  <updated>2013-08-14T23:57:03+08:00</updated>
  <id>http://woody1983.github.com/</id>
  <author>
    <name><![CDATA[Johnny Hsu]]></name>
    <email><![CDATA[unix1983@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fast enumeration]]></title>
    <link href="http://woody1983.github.com/blog/2013/08/14/fast-enumeration/"/>
    <updated>2013-08-14T23:50:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/08/14/fast-enumeration</id>
    <content type="html"><![CDATA[<h3>能多快速？</h3>

<blockquote><p>Objective-C is good at making decisions, but it’s great at being lazy.</p></blockquote>

<h4>笨方法循环打印数组内容</h4>

<p>``` objective-c
NSArray *funnyWords = @[@"Schadenfreude", @"Portmanteau", @"Penultimate"];</p>

<p>NSLog(@"%@ is a funny word", funnyWords[0]);
NSLog(@"%@ is a funny word", funnyWords[1]);
NSLog(@"%@ is a funny word", funnyWords[2]);
```</p>

<h4>更简洁的方法是</h4>

<p>``` objective-c
NSArray *funnyWords = @[@"Schadenfreude", @"Portmanteau", @"Penultimate"];</p>

<p>for (NSString *word in funnyWords) {
  NSLog(@"%@ is a funny word", word);
}
```</p>

<h3>练习</h3>

<p>``` objective-c
NSArray <em>newHats = @[@"Cowboy", @"Conductor", @"Baseball"];
NSString </em>hat; //记得声明
for (hat in newHats) {</p>

<p>  NSLog(@"Trying on new %@ hat", hat);</p>

<p>  if([mrHiggie tryOnHat:hat]) {</p>

<pre><code>NSLog(@"Mr. Higgie loves it");
</code></pre>

<p>  } else {</p>

<pre><code>NSLog(@"Mr. Higgie hates it");
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Try Objective-C]]></title>
    <link href="http://woody1983.github.com/blog/2013/08/11/try-objective-c/"/>
    <updated>2013-08-11T23:30:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/08/11/try-objective-c</id>
    <content type="html"><![CDATA[<h3>Code School 上的免费教程，为什么要着急先把这个免费的学掉 我也不知道具体是为什么。一个月学费20$ 总是出现在我最忙的时候。月底还有考试，真TMD服了。</h3>

<!-- more -->


<h2>常规的一些语法 变量 输出</h2>

<p>``` objective-c</p>

<p>NSLog(@"Hello,Mr.Johnny");
NSString *firstName = @"Johnny Hsu";
NSLog(firstName); //Logging a variable
NSLog(@"Hello there, %@.", firstName );
NSLog(@"%@ %@", firstName, firstName);</p>

<p>NSString *lastName = @"Hsu";</p>

<p>NSLog(@"%@ %@", firstName, lastName);
NSNumber <em>age = @30; //Creating a number object
/</em>
NSNumber <em>ipodBirthdayYear = @2001;
NSNumber </em>iphoneBirthdayYear = @2007;
NSNumber <em>ipadBirthdayYear = @2010;
</em>/</p>

<p>//Log a number object
NSLog(@"%@ is %@ years old", firstName, age);</p>

<p>//Creating an array variable</p>

<p>NSArray *apps = @[@"AngryFowl",@"Lettertouch",@"Tweetrobot"];</p>

<p>//Accessing values in an array
NSLog(@"%@", apps[1]); //challenge[11]: Lettertouch</p>

<p>//Changing an array
apps = @[@"AngryFowl",@"Lettertouch",@"Tweetrobot",@"Instacanvas"];</p>

<h2>Dictionary还是蛮实用的。</h2>

<p>//Creating a dictionary
NSDictionary <em>person = @{@"First Name": @"Johnny"};
NSDictionary </em>appRatings = @{@"AngryFowl": @3, @"Lettertouch": @5};</p>

<p>//Accessing values in a dictionary
NSLog(@"Lettertouch has a rating of %@.", appRatings[@"Lettertouch"]);</p>

<p>```</p>

<h1>基础部分结束</h1>

<h1>Objective-C 有一个特性就是调用一个方法 在这里称之为传递一个信息 不过这么看倒反而形象了。</h1>

<p>``` objective-c
//Sending a message
[tryobjc completeThisChallenge];</p>

<p>//-------------------------Sending the description message
/<em>
Try sending the description message to the foods array inside of NSLog() to see what it returns.
</em>/
NSArray *foods = @[@"tacos", @"burgers"];</p>

<p>NSLog(@"%@", [foods description]);
//--------------------------Storing the result of a message
//NSString *result = [myArrayObject description];</p>

<p>NSArray <em>foods = @[@"tacos", @"burgers"];           <br/>
NSString </em>result = [foods description];</p>

<p>NSLog(@"%@", result);</p>

<p>//--------------------------Trying to log an NSUInteger
NSString *city = @"Ice World";
NSUInteger cityLength = [city length];</p>

<p>NSLog(@"City has %lu characters", cityLength);
//If you want to log an NSUInteger, you can use the %lu placeholder instead of %@.
```</p>

<h2>Operating on NSNumbers</h2>

<p>``` objective-c
/<em>
NSNumber </em>higgiesAge = @6;
NSNumber *phoneLives = @3;</p>

<p>NSUInteger higgiesAgeInt = [higgiesAge unsignedIntegerValue];
NSUInteger phoneLivesInt = [phoneLives unsignedIntegerValue];</p>

<p>NSUInteger higgiesRealAge = higgiesAgeInt * phoneLivesInt;
<em>/
NSNumber </em>higgiesAge = @6;                                                                 <br/>
NSNumber *phoneLives = @3;</p>

<p>NSUInteger higgiesAgeInt = [higgiesAge unsignedIntegerValue];
NSUInteger phoneLivesInt = [phoneLives unsignedIntegerValue];</p>

<p>NSUInteger product = higgiesAgeInt * phoneLivesInt;
NSLog(@"Higgie is actually %lu years old.", product);</p>

<p>//----------------------Appending 2 strings
NSString <em>firstName = @"Johnny Hsu";
NSString </em>lastName = @"Hsu";</p>

<p>NSString <em>fullName = [firstName stringByAppendingString:lastName];
NSLog(@"%@", fullName);
/</em>
Well, it turns out that we can. There is a method on NSString called stringByAppendingString:
that takes a single NSString argument and appends it to the NSString object that received the
stringByAppendingString: message, returning the full string. So we can rewrite the above code like so:
*/
```</p>

<h1>Nesting messages</h1>

<p>``` objective-c
NSString <em>firstName = @"Johnny Hsu";
NSString </em>lastName = @"Hsu";</p>

<p>NSString <em>fullName = [[firstName stringByAppendingString:@" "] stringByAppendingString:lastName ];
 /</em>//Append firstName and lastName with a space between//*/;</p>

<p>NSLog(@"%@", fullName);</p>

<p>//---------------------Working with long message names
NSString <em>firstName = @"Johnny";
NSString </em>lastName = @"Hsu";</p>

<p>NSString *fullName = [[firstName stringByAppendingString:@" "]</p>

<pre><code>                    stringByAppendingString:lastName];
</code></pre>

<p>NSString *replaced = [fullName stringByReplacingOccurrencesOfString:firstName</p>

<pre><code>                                                     withString:lastName];
</code></pre>

<p>NSLog(@"%@", fullName);
NSLog(@"%@", replaced);
/<em>
challenge[9]: Johnny Hsu
challenge[10]: Hsu Hsu
</em>/</p>

<p>//-------------------------Creating an NSString with a message
NSString *firstName = @"Johnny Hsu";</p>

<p>NSString *copy = [NSString stringWithString:firstName];</p>

<p>NSLog(@"%@ is a copy of %@", copy, firstName);
//challenge[5]: Johnny Hsu is a copy of Johnny Hsu</p>

<p>//-------------------------Creating an NSString with alloc/init
/<em>
NSString </em>emptyString = [[NSString alloc] init];
NSArray <em>emptyArray = [[NSArray alloc] init];
NSDictionary </em>emptyDictionary = [[NSDictionary alloc] init];
<em>/
NSString </em>firstName = @"Johnny Hsu";</p>

<p>NSString *copy = [[NSString alloc] initWithString:firstName];</p>

<p>NSLog(@"%@ is a copy of %@", copy, firstName);
//challenge[5]: Johnny Hsu is a copy of Johnny Hsu</p>

<p>//-------------------------Refactoring string combination
NSString <em>firstName = @"Johnny Hsu";
NSString </em>lastName = @"Hsu";</p>

<p>NSString *fullName = [NSString stringWithFormat:@"%@ %@",firstName,lastName];</p>

<p>NSLog(@"%@", fullName);</p>

<p>```</p>

<h1>判断啥的 登场吧</h1>

<p>``` objective-c</p>

<p>//----------------------A simple if
BOOL mrHiggieIsMean = YES;</p>

<p>if (mrHiggieIsMean) {
  NSLog(@"Confirmed: he is super mean");
}
//----------------------if - else
BOOL mrHiggieIsMean = [mrHiggie areYouMean];</p>

<p>if (mrHiggieIsMean) {
  NSLog(@"Confirmed: he is super mean");
}else{
  NSLog(@"Confirmed: he isn't super mean");
}
//----------------------if - else if - else
/<em>
+----------------+-----------------------------------------+
| Meanness Range |               Log String                |
+----------------+-----------------------------------------+
| 0-3            | Mr. Higgie is on the nice side          |
| 4-7            | Mr. Higgie is sorta nice but not really |
| 8-10           | Mr. Higgie is definitely mean           |
+----------------+-----------------------------------------+
</em>/
NSNumber *meannessScale = [mrHiggie meannessScale];</p>

<p>if([meannessScale intValue] &lt; 4) {
  NSLog(@"Mr. Higgie is on the nice side");
} else if([meannessScale intValue] &lt; 8 &amp;&amp; [meannessScale intValue] >3) {
  NSLog(@"Mr. Higgie is sorta nice but not really");
} else {
  NSLog(@"Mr. Higgie is definitely mean");
}</p>

<p>//----------------------Equal strings
NSString *hat = [mrHiggie currentHat];</p>

<p>if([hat isEqualToString:@"Sombrero"]) {
  NSLog(@"Ese es un muy buen sombrero");
} else if ([hat isEqualToString:@"Fedora"]) {
  NSLog(@"Mr. Higgie was an iPhone before there was iPhone");
} else if ([hat isEqualToString:@"AstronautHelmet"]) {
  NSLog(@"Mr. Higgie was an AstronautHelmet");
} else {
  NSLog(@"Mr. Higgie is currently hatless");
}</p>

<p>//--------------------Switch it up
//Mission:He has requested that we please update the switch to let him wear his AstronautHelmet hat on the weekends.
NSInteger day = getDayOfWeek();</p>

<p>switch (day) {
  case 1:
  case 2:
  case 3:
  case 4: {</p>

<pre><code>[mrHiggie setCurrentHat:@"Fedora"];
break;
</code></pre>

<p>  }
  case 5: {</p>

<pre><code>[mrHiggie setCurrentHat:@"Sombrero"];
break;
</code></pre>

<p>  }
  case 6:{</p>

<pre><code>[mrHiggie setCurrentHat:@"AstronautHelmet"];
break;
</code></pre>

<p>  }
  case 7: {</p>

<pre><code>[mrHiggie setCurrentHat:@"AstronautHelmet"];
break;
</code></pre>

<p>  }
}</p>

<p>NSLog(@"Mr. Higgie is wearing: %@", [mrHiggie currentHat]);</p>

<p>//-------------------------Switch on enums
typedef NS_ENUM(NSInteger, DayOfWeek) {</p>

<pre><code>DayOfWeekMonday = 1,
DayOfWeekTuesday = 2,
DayOfWeekWednesday = 3,
DayOfWeekThursday = 4,
DayOfWeekFriday = 5,
DayOfWeekSaturday = 6,
DayOfWeekSunday = 7
</code></pre>

<p>};</p>

<p>//Mission:Finish converting the rest of the cases to use the enum values.
DayOfWeek day = getDayOfWeek();</p>

<p>switch (day) {</p>

<pre><code>case DayOfWeekMonday:
case DayOfWeekTuesday:
case DayOfWeekWednesday:
case DayOfWeekThursday: {
    [mrHiggie setCurrentHat:@"Fedora"];
    break;
}
case DayOfWeekFriday: {
    [mrHiggie setCurrentHat:@"Sombrero"];
    break;
}
case DayOfWeekSaturday:
case DayOfWeekSunday: {
    [mrHiggie setCurrentHat:@"AstronautHelmet"];
    break;
}
</code></pre>

<p>}</p>

<p>NSLog(@"Mr. Higgie is wearing: %@", [mrHiggie currentHat]);</p>

<p>```</p>

<h1>Obviously 还没写完 不能对一个拖延症患者要求太高不是。</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Note:Class init alloc]]></title>
    <link href="http://woody1983.github.com/blog/2013/03/08/objective-c-note-class-init-alloc/"/>
    <updated>2013-03-08T16:58:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/03/08/objective-c-note-class-init-alloc</id>
    <content type="html"><![CDATA[<p>``` objective-c</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface BNRItem : NSObject
{
  NSString <em>itemName;
  NSString </em>serialNumber;
  int valueInDollars;
  NSDate *dateCreated;
}
@end
```</p>

<h3>对象会直接保存非指针类型的实例变量，BNRItem 对象并没有直接保存其他对象，而只拥有三个指针，分别指向另外三个对象。这些指针都是BNRItem的实例变量。</h3>

<h3>也就是说 BNRItem通过一个itemName的指针 指向一个NSString对象。</h3>

<!-- more -->


<p><img src="/images/img/nsobject.jpg"></p>

<h1>实例变量的存取</h1>

<h2>存方法</h2>

<h3>修改实例的变量，指向另一个字符串，该BNRItem对象会将新的NSString对象命名为itemName</h3>

<p><code>objective-c
-(void)setItemName:(NSString *)newItemName
{
  itemName = newItemName;
}
</code></p>

<h2>取方法</h2>

<h3>返回BNRItem名为itemName的实例变量 一个指向NSString对象的指针</h3>

<p><code>objective-c
-(NSString *)itemName
{
  return itemName;
}
</code></p>

<h2>调用</h2>

<p>对BNRItem对象使用setItemName和itemName方法即可实现设置和读取该变量的动作。</p>

<h2>例子</h2>

<p><code>objective-c
//声明
BNRItem *p = [[BNRItem alloc] init];
//设置
[p setItemName:@"Red Sofa"];
//读取
NSString *str = [p itemName];
//输出
NSLog(@"%@", str);
</code></p>

<blockquote><p>但在Objective-C中，取方法的方法名就是实例变量的变量名。</p></blockquote>

<h2>覆盖某种方法 直接定义就可以了</h2>

<h2>关于实例说明</h2>

<p>Description是NSObject类的方法，是一个介绍该类的方法。因为这个类已经在父类NSObject中声明过了，因此只要在定义文件中重新覆盖即可。
``` objective-c
-(NSString <em>)description
{
  NSString </em>descriptionString = [[NSString alloc] initWithFormat:@"%@ (%@): Worth $%d, recorded on %@",</p>

<pre><code>                                               itemName,serialNumber,valueInDollars,dateCreated];
</code></pre>

<p>  return descriptionString;
}</p>

<blockquote><p>向某个BNRItem实例发送description消息就会得到描述该实例的NSString对象，一般情况下格式化说明%@ 程序就先调用实参的description方法。</p></blockquote>

<p>NSLog(@"%@",p);
```</p>

<ul>
<li>alloc 向某个类发送这个信息 是创建该类的实例并得到指向新实例的指针</li>
<li>init 为实例变量设置初始值 编写更复杂的类时 需要创建更多的初始化方法 类似init 但会带参数</li>
</ul>


<h2>原先的代码</h2>

<p>``` objective-c</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface BNRItem : NSObject
{
NSString <em>itemName;
NSString </em>serialNumber;
int valueInDollars;
NSDate <em>dateCreated;
}
- (void)setItemName:(NSString </em>)str;
- (NSString *)itemName;</p>

<ul>
<li>(void)setSerialNumber:(NSString *)str;</li>
<li><p>(NSString *)serialNumber;</p></li>
<li><p>(void)setValueInDollars:(int)i;</p></li>
<li><p>(int)valueInDollars;</p></li>
<li><p>(NSDate *)dateCreated;
@end
```</p>

<h3>要新增的方法</h3></li>
</ul>


<p><code>objective-c
- (id)initWithItemName:(NSString *)name
valueInDollars:(int)value
serialNumber:(NSString *)sNumber;
</code></p>

<blockquote><p>这些参数都有类型和参数名。声明参数时，要先写标签，然后写类型（写在圆括号里），
最后写参数名。以initWithItemName:valueInDollars:serialNumber:为例， 和
initWithItemName:标签对应的参数是指向NSString对象的指针。在该方法的程序段中，
可以用name来引用该指针所指向的NSString对象。</p></blockquote>

<p>这个方法返回的是一个id类型，OC中ID可以指向任意对象的指针。</p>

<h1>实现指定初始化方法</h1>

<p><code>objective-c
@implementation BNRItem
- (id)initWithItemName:(NSString *)name
valueInDollars:(int)value
serialNumber:(NSString *)sNumber
{
// 调用父类的指定初始化方法
  self = [super init];
// 为实例变量设定初始值
  [self setItemName:name];
  [self setSerialNumber:sNumber];
  [self setValueInDollars:value];
  dateCreated = [[NSDate alloc] init];
// 返回初始化后的对象的地址
  return self;
}
</code></p>

<h2>self</h2>

<p><code>self</code>存在于方法中，是一个隐式（implicit）局部变量。编写方法时不需要声明self，并且程序会自动为self赋值，通常情况下，self会用来向对象自己发送消息。</p>

<blockquote><p>初始化方法的最后一行代码必须返回初始化后的对象。</p></blockquote>

<h2>Super</h2>

<p>覆盖某个类的某个方法时 需要保留该方法在父类中的实现，在其基础上扩充子类的实现。</p>

<p><code>objective-c
- (void)someMethod
{
[self doMoreStuff];
[super someMethod];
}
</code></p>

<blockquote><p>以BNRItem的指定初始化方法为例，向super发送init消息会调用NSObject的init。
<code>objective-c
 self = [super init];
</code>
这一步其实是先调用父类的初始化方法后 先将得到的返回值赋给self变量 如果变量是不是nil，如果不是就继续。</p></blockquote>

<h2>一个类可以有多个初始化方法</h2>

<p><code>objective-c
- (id)initWithItemName:(NSString *)name;
//和之前initWithItemName的声明看起来貌似只少了几个参数而已
</code></p>

<blockquote><p>实现initWithItemName:方法时，不需要将指定初始化方法中的代码搬过来再重写一遍。它只需要调用指定初始化方法，将得到的实参作为itemName传入，而其他实参则使用某个默认值传入，代码如下：
<code>objective-c
- (id)initWithItemName:(NSString *)name
{
return [self initWithItemName:name
valueInDollars:0
serialNumber:@""];
}
</code>
这种串联（chain）使用初始化方法的机制可以降低出错的概率，也更容易维护代码。在创建拥有多个初始化方法的类时，需要先将其中的某个初始化方法确定为“指定初始化方法”。然后只在指定初始化方法中编写初始化的核心代码，其他初始化方法只需要调用该核心代码并输入默认值即可。</p></blockquote>

<h2>初始化方法的调用方向</h2>

<p><img src="/images/img/nsobject2.jpg"></p>

<h4>覆盖BNRItem.m中的init方法，调用指定初始化方法，并使用默认值输入所有的实参，代码如下：</h4>

<p><code>objective-c
- (id)init {
return [self initWithItemName:@"Item"
valueInDollars:0
serialNumber:@""];
}
</code></p>

<h1>使用初始化方法</h1>

<p>main.m会向BNRItem实例发送init消息，因为BNRItem类实现了上述两个初始化方法，所以程序会调用该类所实现的init方法，而该方法又会调用initWithItemName:valueInDollars：serialNumber:并输入默认值</p>

<p>测试:main.m中加入一行代码
<code>objective-c
BNRItem *p = [[BNRItem alloc] init];
NSLog(@"%@", p);
// 创建一个新的NSString对象“Red Sofa”，并传给BNRItem对象
[p setItemName:@"Red Sofa"];
</code>
main.h</p>

<p>``` objective-c</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import "BNRItem.h"</h1>

<p>int main (int argc, const char * argv[])
{
@autoreleasepool {
NSMutableArray <em>items = [[NSMutableArray alloc] init];
BNRItem </em>p = [[BNRItem alloc] initWithItemName:@"Red Sofa"
valueInDollars:100
serialNumber:@"A1B2C"];
NSLog(@"%@", p);
items = nil;
}
return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSLog Format]]></title>
    <link href="http://woody1983.github.com/blog/2013/03/06/nslog-format/"/>
    <updated>2013-03-06T23:08:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/03/06/nslog-format</id>
    <content type="html"><![CDATA[<p><img src="/images/img/nslog.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Note2]]></title>
    <link href="http://woody1983.github.com/blog/2013/03/06/objective-c-note2/"/>
    <updated>2013-03-06T16:12:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/03/06/objective-c-note2</id>
    <content type="html"><![CDATA[<blockquote><p>今天的笔记 Objective-C感觉是一种很细腻的语言。</p></blockquote>

<p>``` objective-c
@interface MyObject : NSObject {
[instance variables]
}</p>

<p>[method declarations]
@end</p>

<p>@implementation MyObject
[method implementations]
@end
```</p>

<h3>Method declarations in Objective-C look like this:</h3>

<p><code>objective-c
-(void) launchPlane;
</code></p>

<h3>Here, for example, is a method that takes a single parameters:</h3>

<p><code>objective-c
-(void) launchPlane:(NSString *)planeName;
</code></p>

<h3>two parameters:</h3>

<p><code>objective-c
-(void) launchPlane:(NSString *)planeName fuelCapacity:(int)litresOfFuel;
</code></p>

<h3>实现的时候</h3>

<p>``` objective-c
[planeLauncher launchPlane];</p>

<p>[planeLauncher launchPlane:@"Boeing 747-300" fuelCapacity:183380];
```</p>

<!-- more -->


<blockquote><p>The method declarations for a class are kept in its interface. Here’s an example of what the interface for a class that defines some methods looks like:
<code>objective-c
@interface SomeObject: NSObject
- (void) launchPlane:(NSString*)planeName;
- (int) numberOfPlanesInTheAir;
@end
</code></p></blockquote>

<h2>Properties</h2>

<blockquote><p>In object-oriented programming, it’s considered bad practice for one object to directly access another object’s data. Doing so breaks encapsulation, because it means that one object’s code is now dependent on the data stored in another.In order to access and change another object’s variables, you use a pair of instance methods known as a setterand getter. The getter method returns the current value of the variable, and the setter method changes the value.
In Objective-C, setter and getter method names must follow an established pattern. For example, given an instance variable named  <code>planeName</code>, the setter method would be named <code>setPlaneName:</code>and the getter method would be named <code>planeName</code>.</p></blockquote>

<h3>Declaring a property in an Objective-C class looks like this:</h3>

<p><code>objective-c
@interface SomeClass: NSObject
@property (strong, nonatomic) NSObject* myProperty;
@end
</code></p>

<h1>关于Property</h1>

<h3>strong</h3>

<p>This property is a strong (owning) reference to an object; see  “Object Graphs in
Objective-C”(page  32). Using  strong  and  weakproperties controls whether the ob‐
ject referred to by the property stays in memory or not.</p>

<h3>weak</h3>

<p>This property is a weak (nonowning) reference to an object. When the object re‐
ferred to by this property is deallocated, this property is automatically set to nil.</p>

<h3>assign</h3>

<p>This property’s setter method simply assigns the property’s variable to whatever is
passed in, and performs no memory management.</p>

<h3>copy</h3>

<p>This property’s setter copies any object passed to it, creating a duplicate object.</p>

<h3>readwrite</h3>

<p>This property generates both getter and setter methods. (This attribute is set by
default—you need to explicitly use it only when overriding a superclass’s property.)</p>

<h3>readonly</h3>

<p>This property does not generate a setter method, rendering the property read-only
by other classes. (Your class’s implementation code can still modify the property’s
variable, however.)</p>

<h3>nonatomic</h3>

<p>This property’s setter and getter do not attempt to get a lock before making changes
to the variable, rendering it thread-safe.</p>

<p><code>objective-c
@implementation MyClass
@synthesize myProperty = _myCustomVariableName;
// the rest of the class code goes here
@end
</code></p>

<h2>或者不用@synthesize  而使用@dynamic 来实现getter and setter methods</h2>

<p><code>objective-c
@implementation MyClass
@dynamic myProperty;
- (int) myProperty {
// this is the getter method for this property
return 123;
}
- (void) setMyProperty:(int)newValue {
// this is the setter method for this property
}
@end
</code></p>

<h2>Protocols</h2>

<blockquote><p>A protocolis a list of methods that your class promises to implement. Protocols are used to mark classes as having certain capabilities, like the ability to be copied, to be serialized and deserialized, or to act as a data source for some other class.
<code>objective-c
@protocol SomeProtocol
[ method declarations ]
@end
//用处
You can mark a class as conformingto a protocol by declaring so in the class’s interface:
@interface SomeObject: NSObject &lt;SomeProtocol&gt;
@end
</code></p></blockquote>

<h3>alloc只是给对象保留内存空间，如果要使用必须准备初始化动作。</h3>

<p><code>objective-c
SomeClass* anObject = [[SomeClass alloc] init];
</code></p>

<blockquote><p>Some classes use a different designated initializer, or have multiple initializers you can use. For example, the NSStringclass has several—here are a few:
一些类使用不同的多个初始化方法或多个初始化
<code>objective-c
NSString* myString  = [[NSString alloc] initWithFormat:@"here's a number: %i", 123];
NSString* anotherString = [[NSString alloc] initWithData:anNSDataObject encoding:NSUTF8Encoding];
NSString* oneMoreString = [[NSString alloc] initWithContentsOfFile:@"path to a file" encoding:NSUTF8Encoding error：someErrorPointer];
</code></p></blockquote>

<h1>Foundation</h1>

<h2>String</h2>

<p>Strings are stored in the  NSStringclass, which makes them Objective-C objects just like
everything else. You can create an empty string with this code</p>

<p>``` objective-c
NSString<em> aString = [[NSString alloc] init];
//Doing this isn’t terribly useful, because the NSString class is immutable
NSString</em> aString = @"Hello, world!";</p>

<p>@表示一个NSString对象 可以接受信息，和其他对象互动。
//it can receive messages and generally interact other objects in the application.</p>

<p>NSInteger sizeOfString = [@"Hello, world!" length];
//将这个NSString对象的长度提取出来</p>

<p>还有一些内置方法 比如 大小 小写 首字母大写之类的</p>

<p>NSString<em> originalString  = @"This is An EXAMPLE";
// "THIS IS AN EXAMPLE"
NSString</em> uppercaseString  = [originalString uppercaseString];
// "this is an example"
NSString<em> lowerCaseString  = [originalString lowercaseString];
// "This Is An Example"
NSString</em> capitalizedString = [originalString capitalizedString];
//To get the first five characters in a string, you do this:
NSString<em> startSubstring = [originalString substringToIndex:5]; // "This "
//To get everything past the first five characters:
NSString</em> endSubstring = [originalString substringFromIndex:5]; // "is An EXAMPLE"
//To get a substring of a range of characters, you first create an NSRangestructure, which
//defines the start point and length of the range. For example, to create an NSRangethat
//starts at the third character and is five characters long, you do this:
NSRange theRange = NSMakeRange(2,5);
NSString* substring = [originalString substringWithRange:theRange]; // "is is"
```</p>

<h3>Structures and Objects</h3>

<p>``` objective-c
struct CGPoint {
float x;
float y;
};</p>

<p>CGPoint somePoint;
somePoint.x = 123;
somePoint.y = 456;
// This is a variable that contains a pointer to an NSString
NSString* someString;
// This is a variable that contains a CGPoint
CGPoint somePoint;
```</p>

<h3>判断NSString</h3>

<p><code>objective-c
if (firstString == secondString) {
// Do something
}
if ([firstString isEqualToString:secondString]) {
// Do something
}
</code></p>

<h2>Searching Strings</h2>

<p><code>objective-c
NSString* sourceString = @"Four score and seven years ago";
NSRange range = [sourceString rangeOfString:@"seven"];
if (range.location == NSNotFound) {
// the string was not found
} else {
// the string was found; 'range' variable contains info on where it is
}
</code></p>

<h2>还有一些选项</h2>

<p><code>objective-c
NSString* sourceString = @"Four score and seven years ago";
NSRange range = [sourceString rangeOfString:@"SEVEN"
options:NSCaseInsensitiveSearch];
</code></p>

<h2>Arrays</h2>

<h3>Declaration:</h3>

<p>``` objective-c
NSArray* myArray = @[@"one", @"two", @"three"];</p>

<h3>You can also retrieve objects from an array, using syntax like this:</h3>

<p>NSString<em> oneString = myArray[0];
NSString</em> twoString = myArray[1];</p>

<p>//The syntax for accessing elements in an NSArray doesn’t work on iOS 5 and below.
//Instead, you need to use the slightly wordier method objectAtIndex:, like so:
NSString* oneString = [myArray objectAtIndex:0];</p>

<p>int count = myArray.count;
// count now equals 3</p>

<p>NSArray* myArray = @[@"one", @"two", @"three"];
int index = [myArray indexOfObject:@"two"];  // should be equal to 1
if (index == NSNotFound) {
NSLog(@"Couldn't find the object!");
}</p>

<p>//Here’s an example of creating a subarray from an existing array:
NSArray<em> myArray = @[@"one", @"two", @"three"];
NSRange subArrayRange = NSMakeRange(1,2);
NSArray</em> subArray = [myArray subArrayWithRange:subArrayRange];
// subArray now contains "two", "three"</p>

<h3>Fast Enumeration</h3>

<p>To loop over an array, you do this:</p>

<p>NSArray<em> myArray = @[@"one", @"two", @"three"];
for (NSString</em> string in myArray) {
// this code is repeated 3 times, one for each item in the array
}</p>

<h3>Mutable Arrays</h3>

<p>NSMutableArray* myArray = [NSMutableArray arrayWithArray:@[@"One", @"Two"]];
// Add "Three" to the end
[myArray addObject:@"Three"];
// Add "Zero" to the start
[myArray insertObject:@"Zero" atIndex:0];
// The array now contains "Zero", "One", "Two", "Three"</p>

<p>NSMutableArray* myArray = [NSMutableArray arrayWithArray:@[@"One", @"Two", @"Three"]];
[myArray removeObject:@"One"];  // removes "One"
[myArray removeObjectAtIndex:1]; // removes "Three", the second
// item in the array at this point
// The array now contains just "Two"</p>

<p>NSMutableArray* myArray = [NSMutableArray arrayWithArray:@[@"One", @"Two",@"Three"]];
[myArray replaceObjectAtIndex:1 withObject:@"Bananas"];
// myArray is now "One", "Bananas", "Three"
You can also ask the mutable array to set an object at a given index:
myArray[0] = @"Null";
```</p>

<h2>Dictionaries</h2>

<p>/<em>
Table 3-1. Contact information
Key      Value
Name     Cave Johnson
Company  Aperture Science
Likes    Science
Dislikes Lemons
</em>/
``` objective-c
NSDictionary<em> translationDictionary = @{
@"greeting": @"Hello",
@"farewell": @"Goodbye"
};
//You can retrieve a value from the dictionary in a similar way to how you get objects out of an NSArray:
NSDictionary</em> translationDictionary = @{@"greeting": @"Hello"};
NSString* greeting = translationDictionary[@"greeting"];</p>

<p>// Here, aDictionary is an NSDictionary
for (NSString<em> key in aDictionary) {
NSObject</em> theValue = aDictionary[key];
// do something with theValue
}</p>

<p>//To set an object for a key in a mutable dictionary
NSMutableDictionary* aDictionary = @{};
aDictionary[@"greeting"] = @"Hello";
aDictionary[@"farewell"] = @"Goodbye";</p>

<h3>To create an NSNumber from a number, simply put an @ in front of it.</h3>

<p>NSNumber* theNumber = @123;
//This NSNumberinstance can be included in any collection object:</p>

<p>//'numbers' is an NSMutableArray
[numbers addObject:theNumber];
//This NSNumberinstance can be included in any collection object:</p>

<p>//'numbers' is an NSMutableArray
[numbers addObject:theNumber];
//You can also set NSNumbers to the result of an expression. For example:
int a = 100;
NSNumber* number = @(a+1);
// 'number' contains 101</p>

<h1>Data</h1>

<h3>To load a text file into an NSDataobject, you can do the following:</h3>

<p>// Assuming that there is a text file at /Examples/Test.txt:
NSString<em> filePath = @"/Examples/Test.txt";
NSData</em> loadedData = [NSData dataWithContentsOfFile:filePath];
```</p>

<h2>转换成NSString对象</h2>

<blockquote><p>For example, to convert an  NSDataobject to an  NSString, you can use the  NSString class’s  initWithData:encoding:method, which takes an  NSData  object and  an NSStringEncodingvalue (which indicates to the class how it should interpret the bytes).</p></blockquote>

<p>``` objective-c
NSString* loadedString = [[NSString alloc] initWithData:loadedData  encoding:NSUTF8StringEncoding];</p>

<p>//You can write an  NSDataobject to disk in a similar way
// Here, loadedData is an NSData object
NSString* filePath = @"/Examples/Test.txt";
[loadedData writeToFile:filePath atomically:YES];
```</p>

<h3>The NSCodingprotocol contains two key methods, which your class must implement in order to be serializable:</h3>

<ul>
<li>encodeWithCoder:</li>
<li>initWithCoder:</li>
</ul>


<h3>Here is an example of an implementation of the encodeWithCoder:method:</h3>

<p><code>objective-c
- (void) encodeWithCoder:(NSKeyedArchiver*)aCoder {
// Store a string (or any other Objective-C object that supports coding)
[aCoder encodeObject:myStringVariable forKey:@"myString"];
// Store a number
[aCoder encodeInteger:myIntegerVariable forKey:@"anInteger"];
}
</code></p>

<h3>Here is the corresponding initWithCoder:  method, which sets up the object and loads the encoded data:</h3>

<p><code>objective-c
- (id) initWithCoder:(NSKeyedUnarchiver*)aDecoder {
self = [super init];
myStringVariable = [aDecoder decodeObjectForKey:@"myString"];
myIntegerVariable = [aDecoder decodeIntegerForKey:@"anInteger"];
return self;
}
</code></p>

<h4>To actually convert an object to a usable NSData, you can do this:</h4>

<p><code>objective-c
// myObject is an object that
//conforms to NSCoding
NSData* object storedData = [NSKeyedArchiver archivedDataWithRootObject:myObject];
// storedData can now be written to a file
To load it back, you can do this:
// loadedData is an NSData loaded from somewhere, and SomeObject is
//a class that conforms to NSCoding
SomeObject* myObject = [NSKeyedUnarchiver unarchiveObjectWithData:loadedData];
</code></p>

<h1>Design Patterns in Cocoa</h1>

<blockquote><p>Delegationis Cocoa’s term for passing off some responsibilities of an object to another.An example of this in action is the UIApplicationobject, which represents an application on iOS. This application needs to know what should happen when the application moves to the background. Many other languages handle this problem by subclassing</p></blockquote>

<p><img src="/images/img/ocnote2.png"></p>
]]></content>
  </entry>
  
</feed>
