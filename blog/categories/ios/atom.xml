<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: IOS | 1024Bit  电子游牧日志]]></title>
  <link href="http://woody1983.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://woody1983.github.com/"/>
  <updated>2013-03-19T00:16:10+08:00</updated>
  <id>http://woody1983.github.com/</id>
  <author>
    <name><![CDATA[Woody.Xu]]></name>
    <email><![CDATA[unix1983@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C Note:Class init alloc]]></title>
    <link href="http://woody1983.github.com/blog/2013/03/08/objective-c-note-class-init-alloc/"/>
    <updated>2013-03-08T16:58:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/03/08/objective-c-note-class-init-alloc</id>
    <content type="html"><![CDATA[<p>``` objective-c</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface BNRItem : NSObject
{
  NSString <em>itemName;
  NSString </em>serialNumber;
  int valueInDollars;
  NSDate *dateCreated;
}
@end
```</p>

<h3>对象会直接保存非指针类型的实例变量，BNRItem 对象并没有直接保存其他对象，而只拥有三个指针，分别指向另外三个对象。这些指针都是BNRItem的实例变量。</h3>

<h3>也就是说 BNRItem通过一个itemName的指针 指向一个NSString对象。</h3>

<!-- more -->


<p><img src="/images/img/nsobject.jpg"></p>

<h1>实例变量的存取</h1>

<h2>存方法</h2>

<h3>修改实例的变量，指向另一个字符串，该BNRItem对象会将新的NSString对象命名为itemName</h3>

<p><code>objective-c
-(void)setItemName:(NSString *)newItemName
{
  itemName = newItemName;
}
</code></p>

<h2>取方法</h2>

<h3>返回BNRItem名为itemName的实例变量 一个指向NSString对象的指针</h3>

<p><code>objective-c
-(NSString *)itemName
{
  return itemName;
}
</code></p>

<h2>调用</h2>

<p>对BNRItem对象使用setItemName和itemName方法即可实现设置和读取该变量的动作。</p>

<h2>例子</h2>

<p><code>objective-c
//声明
BNRItem *p = [[BNRItem alloc] init];
//设置
[p setItemName:@"Red Sofa"];
//读取
NSString *str = [p itemName];
//输出
NSLog(@"%@", str);
</code></p>

<blockquote><p>但在Objective-C中，取方法的方法名就是实例变量的变量名。</p></blockquote>

<h2>覆盖某种方法 直接定义就可以了</h2>

<h2>关于实例说明</h2>

<p>Description是NSObject类的方法，是一个介绍该类的方法。因为这个类已经在父类NSObject中声明过了，因此只要在定义文件中重新覆盖即可。
``` objective-c
-(NSString <em>)description
{
  NSString </em>descriptionString = [[NSString alloc] initWithFormat:@"%@ (%@): Worth $%d, recorded on %@",</p>

<pre><code>                                               itemName,serialNumber,valueInDollars,dateCreated];
</code></pre>

<p>  return descriptionString;
}</p>

<blockquote><p>向某个BNRItem实例发送description消息就会得到描述该实例的NSString对象，一般情况下格式化说明%@ 程序就先调用实参的description方法。</p></blockquote>

<p>NSLog(@"%@",p);
```</p>

<ul>
<li>alloc 向某个类发送这个信息 是创建该类的实例并得到指向新实例的指针</li>
<li>init 为实例变量设置初始值 编写更复杂的类时 需要创建更多的初始化方法 类似init 但会带参数</li>
</ul>


<h2>原先的代码</h2>

<p>``` objective-c</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface BNRItem : NSObject
{
NSString <em>itemName;
NSString </em>serialNumber;
int valueInDollars;
NSDate <em>dateCreated;
}
- (void)setItemName:(NSString </em>)str;
- (NSString *)itemName;</p>

<ul>
<li>(void)setSerialNumber:(NSString *)str;</li>
<li><p>(NSString *)serialNumber;</p></li>
<li><p>(void)setValueInDollars:(int)i;</p></li>
<li><p>(int)valueInDollars;</p></li>
<li><p>(NSDate *)dateCreated;
@end
```</p>

<h3>要新增的方法</h3></li>
</ul>


<p><code>objective-c
- (id)initWithItemName:(NSString *)name
valueInDollars:(int)value
serialNumber:(NSString *)sNumber;
</code></p>

<blockquote><p>这些参数都有类型和参数名。声明参数时，要先写标签，然后写类型（写在圆括号里），
最后写参数名。以initWithItemName:valueInDollars:serialNumber:为例， 和
initWithItemName:标签对应的参数是指向NSString对象的指针。在该方法的程序段中，
可以用name来引用该指针所指向的NSString对象。</p></blockquote>

<p>这个方法返回的是一个id类型，OC中ID可以指向任意对象的指针。</p>

<h1>实现指定初始化方法</h1>

<p><code>objective-c
@implementation BNRItem
- (id)initWithItemName:(NSString *)name
valueInDollars:(int)value
serialNumber:(NSString *)sNumber
{
// 调用父类的指定初始化方法
  self = [super init];
// 为实例变量设定初始值
  [self setItemName:name];
  [self setSerialNumber:sNumber];
  [self setValueInDollars:value];
  dateCreated = [[NSDate alloc] init];
// 返回初始化后的对象的地址
  return self;
}
</code></p>

<h2>self</h2>

<p><code>self</code>存在于方法中，是一个隐式（implicit）局部变量。编写方法时不需要声明self，并且程序会自动为self赋值，通常情况下，self会用来向对象自己发送消息。</p>

<blockquote><p>初始化方法的最后一行代码必须返回初始化后的对象。</p></blockquote>

<h2>Super</h2>

<p>覆盖某个类的某个方法时 需要保留该方法在父类中的实现，在其基础上扩充子类的实现。</p>

<p><code>objective-c
- (void)someMethod
{
[self doMoreStuff];
[super someMethod];
}
</code></p>

<blockquote><p>以BNRItem的指定初始化方法为例，向super发送init消息会调用NSObject的init。
<code>objective-c
 self = [super init];
</code>
这一步其实是先调用父类的初始化方法后 先将得到的返回值赋给self变量 如果变量是不是nil，如果不是就继续。</p></blockquote>

<h2>一个类可以有多个初始化方法</h2>

<p><code>objective-c
- (id)initWithItemName:(NSString *)name;
//和之前initWithItemName的声明看起来貌似只少了几个参数而已
</code></p>

<blockquote><p>实现initWithItemName:方法时，不需要将指定初始化方法中的代码搬过来再重写一遍。它只需要调用指定初始化方法，将得到的实参作为itemName传入，而其他实参则使用某个默认值传入，代码如下：
<code>objective-c
- (id)initWithItemName:(NSString *)name
{
return [self initWithItemName:name
valueInDollars:0
serialNumber:@""];
}
</code>
这种串联（chain）使用初始化方法的机制可以降低出错的概率，也更容易维护代码。在创建拥有多个初始化方法的类时，需要先将其中的某个初始化方法确定为“指定初始化方法”。然后只在指定初始化方法中编写初始化的核心代码，其他初始化方法只需要调用该核心代码并输入默认值即可。</p></blockquote>

<h2>初始化方法的调用方向</h2>

<p><img src="/images/img/nsobject2.jpg"></p>

<h4>覆盖BNRItem.m中的init方法，调用指定初始化方法，并使用默认值输入所有的实参，代码如下：</h4>

<p><code>objective-c
- (id)init {
return [self initWithItemName:@"Item"
valueInDollars:0
serialNumber:@""];
}
</code></p>

<h1>使用初始化方法</h1>

<p>main.m会向BNRItem实例发送init消息，因为BNRItem类实现了上述两个初始化方法，所以程序会调用该类所实现的init方法，而该方法又会调用initWithItemName:valueInDollars：serialNumber:并输入默认值</p>

<p>测试:main.m中加入一行代码
<code>objective-c
BNRItem *p = [[BNRItem alloc] init];
NSLog(@"%@", p);
// 创建一个新的NSString对象“Red Sofa”，并传给BNRItem对象
[p setItemName:@"Red Sofa"];
</code>
main.h</p>

<p>``` objective-c</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import "BNRItem.h"</h1>

<p>int main (int argc, const char * argv[])
{
@autoreleasepool {
NSMutableArray <em>items = [[NSMutableArray alloc] init];
BNRItem </em>p = [[BNRItem alloc] initWithItemName:@"Red Sofa"
valueInDollars:100
serialNumber:@"A1B2C"];
NSLog(@"%@", p);
items = nil;
}
return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSLog Format]]></title>
    <link href="http://woody1983.github.com/blog/2013/03/06/nslog-format/"/>
    <updated>2013-03-06T23:08:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/03/06/nslog-format</id>
    <content type="html"><![CDATA[<p><img src="/images/img/nslog.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Note2]]></title>
    <link href="http://woody1983.github.com/blog/2013/03/06/objective-c-note2/"/>
    <updated>2013-03-06T16:12:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/03/06/objective-c-note2</id>
    <content type="html"><![CDATA[<blockquote><p>今天的笔记 Objective-C感觉是一种很细腻的语言。</p></blockquote>

<p>``` objective-c
@interface MyObject : NSObject {
[instance variables]
}</p>

<p>[method declarations]
@end</p>

<p>@implementation MyObject
[method implementations]
@end
```</p>

<h3>Method declarations in Objective-C look like this:</h3>

<p><code>objective-c
-(void) launchPlane;
</code></p>

<h3>Here, for example, is a method that takes a single parameters:</h3>

<p><code>objective-c
-(void) launchPlane:(NSString *)planeName;
</code></p>

<h3>two parameters:</h3>

<p><code>objective-c
-(void) launchPlane:(NSString *)planeName fuelCapacity:(int)litresOfFuel;
</code></p>

<h3>实现的时候</h3>

<p>``` objective-c
[planeLauncher launchPlane];</p>

<p>[planeLauncher launchPlane:@"Boeing 747-300" fuelCapacity:183380];
```</p>

<!-- more -->


<blockquote><p>The method declarations for a class are kept in its interface. Here’s an example of what the interface for a class that defines some methods looks like:
<code>objective-c
@interface SomeObject: NSObject
- (void) launchPlane:(NSString*)planeName;
- (int) numberOfPlanesInTheAir;
@end
</code></p></blockquote>

<h2>Properties</h2>

<blockquote><p>In object-oriented programming, it’s considered bad practice for one object to directly access another object’s data. Doing so breaks encapsulation, because it means that one object’s code is now dependent on the data stored in another.In order to access and change another object’s variables, you use a pair of instance methods known as a setterand getter. The getter method returns the current value of the variable, and the setter method changes the value.
In Objective-C, setter and getter method names must follow an established pattern. For example, given an instance variable named  <code>planeName</code>, the setter method would be named <code>setPlaneName:</code>and the getter method would be named <code>planeName</code>.</p></blockquote>

<h3>Declaring a property in an Objective-C class looks like this:</h3>

<p><code>objective-c
@interface SomeClass: NSObject
@property (strong, nonatomic) NSObject* myProperty;
@end
</code></p>

<h1>关于Property</h1>

<h3>strong</h3>

<p>This property is a strong (owning) reference to an object; see  “Object Graphs in
Objective-C”(page  32). Using  strong  and  weakproperties controls whether the ob‐
ject referred to by the property stays in memory or not.</p>

<h3>weak</h3>

<p>This property is a weak (nonowning) reference to an object. When the object re‐
ferred to by this property is deallocated, this property is automatically set to nil.</p>

<h3>assign</h3>

<p>This property’s setter method simply assigns the property’s variable to whatever is
passed in, and performs no memory management.</p>

<h3>copy</h3>

<p>This property’s setter copies any object passed to it, creating a duplicate object.</p>

<h3>readwrite</h3>

<p>This property generates both getter and setter methods. (This attribute is set by
default—you need to explicitly use it only when overriding a superclass’s property.)</p>

<h3>readonly</h3>

<p>This property does not generate a setter method, rendering the property read-only
by other classes. (Your class’s implementation code can still modify the property’s
variable, however.)</p>

<h3>nonatomic</h3>

<p>This property’s setter and getter do not attempt to get a lock before making changes
to the variable, rendering it thread-safe.</p>

<p><code>objective-c
@implementation MyClass
@synthesize myProperty = _myCustomVariableName;
// the rest of the class code goes here
@end
</code></p>

<h2>或者不用@synthesize  而使用@dynamic 来实现getter and setter methods</h2>

<p><code>objective-c
@implementation MyClass
@dynamic myProperty;
- (int) myProperty {
// this is the getter method for this property
return 123;
}
- (void) setMyProperty:(int)newValue {
// this is the setter method for this property
}
@end
</code></p>

<h2>Protocols</h2>

<blockquote><p>A protocolis a list of methods that your class promises to implement. Protocols are used to mark classes as having certain capabilities, like the ability to be copied, to be serialized and deserialized, or to act as a data source for some other class.
<code>objective-c
@protocol SomeProtocol
[ method declarations ]
@end
//用处
You can mark a class as conformingto a protocol by declaring so in the class’s interface:
@interface SomeObject: NSObject &lt;SomeProtocol&gt;
@end
</code></p></blockquote>

<h3>alloc只是给对象保留内存空间，如果要使用必须准备初始化动作。</h3>

<p><code>objective-c
SomeClass* anObject = [[SomeClass alloc] init];
</code></p>

<blockquote><p>Some classes use a different designated initializer, or have multiple initializers you can use. For example, the NSStringclass has several—here are a few:
一些类使用不同的多个初始化方法或多个初始化
<code>objective-c
NSString* myString  = [[NSString alloc] initWithFormat:@"here's a number: %i", 123];
NSString* anotherString = [[NSString alloc] initWithData:anNSDataObject encoding:NSUTF8Encoding];
NSString* oneMoreString = [[NSString alloc] initWithContentsOfFile:@"path to a file" encoding:NSUTF8Encoding error：someErrorPointer];
</code></p></blockquote>

<h1>Foundation</h1>

<h2>String</h2>

<p>Strings are stored in the  NSStringclass, which makes them Objective-C objects just like
everything else. You can create an empty string with this code</p>

<p>``` objective-c
NSString<em> aString = [[NSString alloc] init];
//Doing this isn’t terribly useful, because the NSString class is immutable
NSString</em> aString = @"Hello, world!";</p>

<p>@表示一个NSString对象 可以接受信息，和其他对象互动。
//it can receive messages and generally interact other objects in the application.</p>

<p>NSInteger sizeOfString = [@"Hello, world!" length];
//将这个NSString对象的长度提取出来</p>

<p>还有一些内置方法 比如 大小 小写 首字母大写之类的</p>

<p>NSString<em> originalString  = @"This is An EXAMPLE";
// "THIS IS AN EXAMPLE"
NSString</em> uppercaseString  = [originalString uppercaseString];
// "this is an example"
NSString<em> lowerCaseString  = [originalString lowercaseString];
// "This Is An Example"
NSString</em> capitalizedString = [originalString capitalizedString];
//To get the first five characters in a string, you do this:
NSString<em> startSubstring = [originalString substringToIndex:5]; // "This "
//To get everything past the first five characters:
NSString</em> endSubstring = [originalString substringFromIndex:5]; // "is An EXAMPLE"
//To get a substring of a range of characters, you first create an NSRangestructure, which
//defines the start point and length of the range. For example, to create an NSRangethat
//starts at the third character and is five characters long, you do this:
NSRange theRange = NSMakeRange(2,5);
NSString* substring = [originalString substringWithRange:theRange]; // "is is"
```</p>

<h3>Structures and Objects</h3>

<p>``` objective-c
struct CGPoint {
float x;
float y;
};</p>

<p>CGPoint somePoint;
somePoint.x = 123;
somePoint.y = 456;
// This is a variable that contains a pointer to an NSString
NSString* someString;
// This is a variable that contains a CGPoint
CGPoint somePoint;
```</p>

<h3>判断NSString</h3>

<p><code>objective-c
if (firstString == secondString) {
// Do something
}
if ([firstString isEqualToString:secondString]) {
// Do something
}
</code></p>

<h2>Searching Strings</h2>

<p><code>objective-c
NSString* sourceString = @"Four score and seven years ago";
NSRange range = [sourceString rangeOfString:@"seven"];
if (range.location == NSNotFound) {
// the string was not found
} else {
// the string was found; 'range' variable contains info on where it is
}
</code></p>

<h2>还有一些选项</h2>

<p><code>objective-c
NSString* sourceString = @"Four score and seven years ago";
NSRange range = [sourceString rangeOfString:@"SEVEN"
options:NSCaseInsensitiveSearch];
</code></p>

<h2>Arrays</h2>

<h3>Declaration:</h3>

<p>``` objective-c
NSArray* myArray = @[@"one", @"two", @"three"];</p>

<h3>You can also retrieve objects from an array, using syntax like this:</h3>

<p>NSString<em> oneString = myArray[0];
NSString</em> twoString = myArray[1];</p>

<p>//The syntax for accessing elements in an NSArray doesn’t work on iOS 5 and below.
//Instead, you need to use the slightly wordier method objectAtIndex:, like so:
NSString* oneString = [myArray objectAtIndex:0];</p>

<p>int count = myArray.count;
// count now equals 3</p>

<p>NSArray* myArray = @[@"one", @"two", @"three"];
int index = [myArray indexOfObject:@"two"];  // should be equal to 1
if (index == NSNotFound) {
NSLog(@"Couldn't find the object!");
}</p>

<p>//Here’s an example of creating a subarray from an existing array:
NSArray<em> myArray = @[@"one", @"two", @"three"];
NSRange subArrayRange = NSMakeRange(1,2);
NSArray</em> subArray = [myArray subArrayWithRange:subArrayRange];
// subArray now contains "two", "three"</p>

<h3>Fast Enumeration</h3>

<p>To loop over an array, you do this:</p>

<p>NSArray<em> myArray = @[@"one", @"two", @"three"];
for (NSString</em> string in myArray) {
// this code is repeated 3 times, one for each item in the array
}</p>

<h3>Mutable Arrays</h3>

<p>NSMutableArray* myArray = [NSMutableArray arrayWithArray:@[@"One", @"Two"]];
// Add "Three" to the end
[myArray addObject:@"Three"];
// Add "Zero" to the start
[myArray insertObject:@"Zero" atIndex:0];
// The array now contains "Zero", "One", "Two", "Three"</p>

<p>NSMutableArray* myArray = [NSMutableArray arrayWithArray:@[@"One", @"Two", @"Three"]];
[myArray removeObject:@"One"];  // removes "One"
[myArray removeObjectAtIndex:1]; // removes "Three", the second
// item in the array at this point
// The array now contains just "Two"</p>

<p>NSMutableArray* myArray = [NSMutableArray arrayWithArray:@[@"One", @"Two",@"Three"]];
[myArray replaceObjectAtIndex:1 withObject:@"Bananas"];
// myArray is now "One", "Bananas", "Three"
You can also ask the mutable array to set an object at a given index:
myArray[0] = @"Null";
```</p>

<h2>Dictionaries</h2>

<p>/<em>
Table 3-1. Contact information
Key      Value
Name     Cave Johnson
Company  Aperture Science
Likes    Science
Dislikes Lemons
</em>/
``` objective-c
NSDictionary<em> translationDictionary = @{
@"greeting": @"Hello",
@"farewell": @"Goodbye"
};
//You can retrieve a value from the dictionary in a similar way to how you get objects out of an NSArray:
NSDictionary</em> translationDictionary = @{@"greeting": @"Hello"};
NSString* greeting = translationDictionary[@"greeting"];</p>

<p>// Here, aDictionary is an NSDictionary
for (NSString<em> key in aDictionary) {
NSObject</em> theValue = aDictionary[key];
// do something with theValue
}</p>

<p>//To set an object for a key in a mutable dictionary
NSMutableDictionary* aDictionary = @{};
aDictionary[@"greeting"] = @"Hello";
aDictionary[@"farewell"] = @"Goodbye";</p>

<h3>To create an NSNumber from a number, simply put an @ in front of it.</h3>

<p>NSNumber* theNumber = @123;
//This NSNumberinstance can be included in any collection object:</p>

<p>//'numbers' is an NSMutableArray
[numbers addObject:theNumber];
//This NSNumberinstance can be included in any collection object:</p>

<p>//'numbers' is an NSMutableArray
[numbers addObject:theNumber];
//You can also set NSNumbers to the result of an expression. For example:
int a = 100;
NSNumber* number = @(a+1);
// 'number' contains 101</p>

<h1>Data</h1>

<h3>To load a text file into an NSDataobject, you can do the following:</h3>

<p>// Assuming that there is a text file at /Examples/Test.txt:
NSString<em> filePath = @"/Examples/Test.txt";
NSData</em> loadedData = [NSData dataWithContentsOfFile:filePath];
```</p>

<h2>转换成NSString对象</h2>

<blockquote><p>For example, to convert an  NSDataobject to an  NSString, you can use the  NSString class’s  initWithData:encoding:method, which takes an  NSData  object and  an NSStringEncodingvalue (which indicates to the class how it should interpret the bytes).</p></blockquote>

<p>``` objective-c
NSString* loadedString = [[NSString alloc] initWithData:loadedData  encoding:NSUTF8StringEncoding];</p>

<p>//You can write an  NSDataobject to disk in a similar way
// Here, loadedData is an NSData object
NSString* filePath = @"/Examples/Test.txt";
[loadedData writeToFile:filePath atomically:YES];
```</p>

<h3>The NSCodingprotocol contains two key methods, which your class must implement in order to be serializable:</h3>

<ul>
<li>encodeWithCoder:</li>
<li>initWithCoder:</li>
</ul>


<h3>Here is an example of an implementation of the encodeWithCoder:method:</h3>

<p><code>objective-c
- (void) encodeWithCoder:(NSKeyedArchiver*)aCoder {
// Store a string (or any other Objective-C object that supports coding)
[aCoder encodeObject:myStringVariable forKey:@"myString"];
// Store a number
[aCoder encodeInteger:myIntegerVariable forKey:@"anInteger"];
}
</code></p>

<h3>Here is the corresponding initWithCoder:  method, which sets up the object and loads the encoded data:</h3>

<p><code>objective-c
- (id) initWithCoder:(NSKeyedUnarchiver*)aDecoder {
self = [super init];
myStringVariable = [aDecoder decodeObjectForKey:@"myString"];
myIntegerVariable = [aDecoder decodeIntegerForKey:@"anInteger"];
return self;
}
</code></p>

<h4>To actually convert an object to a usable NSData, you can do this:</h4>

<p><code>objective-c
// myObject is an object that
//conforms to NSCoding
NSData* object storedData = [NSKeyedArchiver archivedDataWithRootObject:myObject];
// storedData can now be written to a file
To load it back, you can do this:
// loadedData is an NSData loaded from somewhere, and SomeObject is
//a class that conforms to NSCoding
SomeObject* myObject = [NSKeyedUnarchiver unarchiveObjectWithData:loadedData];
</code></p>

<h1>Design Patterns in Cocoa</h1>

<blockquote><p>Delegationis Cocoa’s term for passing off some responsibilities of an object to another.An example of this in action is the UIApplicationobject, which represents an application on iOS. This application needs to know what should happen when the application moves to the background. Many other languages handle this problem by subclassing</p></blockquote>

<p><img src="/images/img/ocnote2.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Demo Note]]></title>
    <link href="http://woody1983.github.com/blog/2013/03/05/objective-c-demo-note/"/>
    <updated>2013-03-05T16:38:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/03/05/objective-c-demo-note</id>
    <content type="html"><![CDATA[<h1>Project:Single View Application</h1>

<h2>MyFirstApp</h2>

<p><code>viewController.h</code></p>

<p>``` objective-c</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface ViewController : UIViewController{
  IBOutlet UILabel *nameLabel //新增一个数据成员
}
-(IBAction)showName:(id)sender; //新增一个方法showName
@end
```</p>

<p><code>viewController.m</code></p>

<p>``` objective-c</p>

<h1>import "viewController.h"</h1>

<p>@implementation ViewController
-(void)didReceiveMemoryWaring
{
  [super didReceiveMemoryWaring];
  // 自带的？ Release any cache data, images, etc that aren't in use.
}</p>

<p>-(IBAction)showName:(id)sender
{
  [nameLabel setText:@"My name is Johnny!"];
}
```</p>

<ul>
<li>@interface 是声明一个类 大括号里面定义的是这个类的数据成员</li>
<li>在@end 之前定义的都是类方法  只定义 实现在@implementation部分实现</li>
<li>didReceiveMemoryWaring这个方法好像是自定义出来的</li>
</ul>


<!-- more -->


<h1>Project RadioStation</h1>

<h3>添加一个Objective-C Class : RadioStation</h3>

<p><code>RadioStation.h</code></p>

<p>``` objective-c</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface RadioStation : NSObject
{</p>

<pre><code>NSString *name;
double frequency;
NSUInteger band;
</code></pre>

<p>}</p>

<p>+(double)minAMFrequency;
+(double)maxAMFrequency;
+(double)minFMFrequency;
+(double)maxFMFrequency;</p>

<p>-(id)initWithName:(NSString <em>)newName atFrequency:(double)newFrequency;
-(NSString </em>)name;
-(void)setName:(NSString *)newName;
-(double)frequency;
-(void)setFrequency:(double)newFrequency;</p>

<p>@end
```</p>

<p><code>RadioStation.m</code></p>

<p>``` objective-c</p>

<h1>import "RadioStation.h"</h1>

<p>@implementation RadioStation
+(double)minAMFrequency
{</p>

<pre><code>return 520.0;
</code></pre>

<p>}</p>

<p>+(double)maxAMFrequency
{</p>

<pre><code>return 1610.0;
</code></pre>

<p>}</p>

<p>+(double)minFMFrequency
{</p>

<pre><code>return 88.3;
</code></pre>

<p>}
+(double)maxFMFrequency
{</p>

<pre><code>return 107.9;
</code></pre>

<p>}</p>

<p>-(id)initWithName:(NSString *)newName atFrequency:(double)newFrequency
{</p>

<pre><code>self = [super init];
NSLog(@"initWithName is Running!\n newFrequency is %f , name is %@",newFrequency,newName);
if (self != nil) {
    name = newName;
    frequency = newFrequency;
}
return self;
</code></pre>

<p>}</p>

<p>-(NSString *)name
{</p>

<pre><code>return name;
NSLog(@"name is ok");
</code></pre>

<p>}
-(double)frequency{</p>

<pre><code>return frequency;
</code></pre>

<p>}</p>

<p>-(void)setName:(NSString *)newName{</p>

<pre><code>name = newName;
</code></pre>

<p>}</p>

<p>-(void)setFrequency:(double)newFrequency{</p>

<pre><code>frequency = newFrequency;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p><code>viewController.h</code></p>

<p>``` objective-c</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@class RadioStation;</p>

<p>@interface XYZViewController : UIViewController
{</p>

<pre><code>RadioStation *myStation;
IBOutlet UILabel* stationName;
IBOutlet UILabel* stationFrequency;
IBOutlet UILabel* stationBand;
</code></pre>

<p>}
@end
```</p>

<p><code>viewController.m</code></p>

<p>``` objective-c</p>

<h1>import "XYZViewController.h"</h1>

<h1>import "RadioStation.h"</h1>

<p>@interface XYZViewController ()</p>

<p>@end</p>

<p>@implementation XYZViewController</p>

<p>-(IBAction)buttonClick:(id)sender{</p>

<pre><code>[stationName setText:[myStation name]];
[stationFrequency setText:[NSString stringWithFormat:@"%.1f",[myStation frequency]]];
if (([myStation frequency] &gt;= [RadioStation minFMFrequency]) &amp;&amp;
    ([myStation frequency] &lt;= [RadioStation maxFMFrequency])) {
    [stationBand setText:@"FM"];
}else{
    [stationBand setText:@"AM"];
}
NSLog(@"buttonClick frequency = %f", [myStation frequency]);
</code></pre>

<p>}</p>

<ul>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];
  myStation = [[RadioStation alloc] initWithName:@"Woody Style" atFrequency:94.1];
  NSLog(@"App is Running");
// Do any additional setup after loading the view, typically from a nib.
}</p></li>
<li><p>(void)viewDidUnload
{
  [super viewDidUnload];
  // Release any retained subviews of the main view.</p></li>
</ul>


<p>}</p>

<ul>
<li>(BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation
{
  return (interfaceOrientation != UIInterfaceOrientationPortraitUpsideDown);
}</li>
</ul>


<p>@end</p>

<p>```</p>

<p><img src="/images/img/oc_demo1.png" title="" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Note]]></title>
    <link href="http://woody1983.github.com/blog/2013/03/05/objective-c-note/"/>
    <updated>2013-03-05T14:18:00+08:00</updated>
    <id>http://woody1983.github.com/blog/2013/03/05/objective-c-note</id>
    <content type="html"><![CDATA[<p>``` objective-c</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface HelloWorld : NSObject
{
}
-(void)printGreeting;
@end</p>

<p>@implementation HelloWorld</p>

<p>-(void)printGreeting
{</p>

<pre><code>    NSLog(@"Hello World!");
</code></pre>

<p>}</p>

<p>@end</p>

<h1>import "HelloWorld.h"</h1>

<p>int main(void)
{
  HelloWorld* myObject = [[HelloWorld alloc] init];
  [myObject printGreeting];</p>

<p>  [myObject release];
  return 0;
}
```</p>

<!-- more -->


<h3>还有上午其他的例子</h3>

<p>``` objective-c
//@"这里的内容应该作为Cocoa的NSString元素来处理"</p>

<p>// 定义函数
BOOL areIntsDifferent(int thing1, int thing2)
{
  if (thing1 == thing2) {</p>

<pre><code>return (NO);
</code></pre>

<p>  }
  else {</p>

<pre><code>return (YES);
</code></pre>

<p>  }
}</p>

<p>// 返回一个BOOL类型的值  接受2个int类型的参数</p>

<p>NSString *boolString (BOOL yesNo)
{
  if (yesNo == NO){</p>

<pre><code>return (@"NO");
</code></pre>

<p>  }
  else
  {</p>

<pre><code>return (@"YES");
</code></pre>

<p>  }
}</p>

<p>返回类型 函数名(参数类型 参数,参数类型1 参数1)
{
// ...  code in here
}</p>

<p>main函数里调用的时候 先声明一个BOOL类型的变量</p>

<p>BOOL areTheyDifferent;
areTheyDifferent = areIntsDifferent(5,5);</p>

<p>NSLog(@"are %d and %d different? %@", 5,5, boolString(areTheyDifferent));// 直接用返回值做参数</p>

<p>//定义一个类  @interface 将该类的数据成员和特性告诉给编译器</p>

<p>@interface Circle : NSObject  // 类名 来自NSObject类
{
  ShapeColor fillColor;
  ShapeRect bounds;
} // 告诉编译器circle对象需要的数据成员
//下面是方法的声明
-(void) draw; //方法需要参数的时候才需要一个冒号 否则就不需要
-(void) setFillColor : (ShapeColor) fillColor; //参数的类型在圆括号里定义!?
-(void) setBounds : (ShapeRect) bounds;</p>

<p>// void表示无返回值  -符号表示是类方法 区别于一般的函数原型和方法声明
// setFillColor 需要一个颜色参数
@end</p>

<p>// @implementation 中定义了类的实现部分</p>

<p>@implementation Circle</p>

<p>-(void) setFillColor: (ShapeColor) c //这个c是参数的重命名!!! @implementation 和 @interface的参数名不同是正确的。如果一致则会报错。
{
  fillColor = c;
}</p>

<p>-(void) setBounds: (ShapeRect) b
{
  bounds = b;
}</p>

<p>-(void) draw
{
  NSLog (@"drawing a circle at (%d %d %d %d) in %@",</p>

<pre><code>bounds.x, bounds.y,
bounds.width, bounds.height,
colorName(fillColor)
</code></pre>

<p>  );
}</p>

<p>@end
```</p>
]]></content>
  </entry>
  
</feed>
